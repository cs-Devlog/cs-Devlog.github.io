<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[백준/2138 전구와 스위치]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/30/%EB%B0%B1%EC%A4%80-2138-%EC%A0%84%EA%B5%AC%EC%99%80-%EC%8A%A4%EC%9C%84%EC%B9%98/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 전구와 스위치 문제는 비트마스크 연산으로 구현한다.  Backtracking으로 앞에서부터 비교하며 모든 경우를 확인한다.  스위치를 누르는 과정을 XOR 연산을 활용하면 스위치를 켜고 끄는 구현을 편하게 할 수 있다.  첫 번째 스위치를 누르고 시작하는 경우 / 누르지 않고 시작하는 경우 로 나눠 시작한다.  두 번째 스위치부터 n-1 번째 스위치 값과 비교한다.          input[n-1] == target[n-1] 이라면 스위치를 누르지 않는다.      input[n-1] != target[n-1] 이라면 스위치를 누른다.      (총 길이 - 1) 번째 까지 반복한다.        (총 길이 - 1) 에 접근 시 스위치를 누를 때 / 누르지 않을 때를 비교한다.&lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static char[] input, target;    public static int ans = Integer.MAX_VALUE;    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        int n = Integer.parseInt(br.readLine());        input = br.readLine().toCharArray();        target = br.readLine().toCharArray();        Backtracking(1, 0);        input[0] ^= 1;        input[1] ^= 1;        Backtracking(1, 1);        System.out.println(ans == Integer.MAX_VALUE ? -1 : ans);    }    public static void Backtracking(int idx, int cnt) {        if (idx == input.length - 1) {            // n-1번째 스위치를 누르지 않아도 같은 경우            if (input[idx] == target[idx] &amp;&amp; input[idx - 1] == target[idx - 1]) {                ans = Math.min(ans, cnt);                return;            }            // n-1번째 스위치를 누르면 같아지는 경우            if ((input[idx] ^ 1) == target[idx] &amp;&amp; (input[idx - 1] ^ 1) == target[idx - 1]) {                ans = Math.min(ans, cnt + 1);                return;            } else return;        }        if (input[idx - 1] == target[idx - 1])  //idx-1번째 스위치가 같으면 스위치를 누를 필요 없다.            Backtracking(idx + 1, cnt);         else {            //idx번째 스위치 누른 경우            input[idx] ^= 1;            input[idx - 1] ^= 1;            input[idx + 1] ^= 1;            Backtracking(idx + 1, cnt + 1);            input[idx] ^= 1;            input[idx - 1] ^= 1;            input[idx + 1] ^= 1;        }        return;    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 2138 </tag>
        
          <tag> 백준 전구와 스위치 </tag>
        
          <tag> 비트마스크 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TCP/IP]]></title>
      <url>/network/2019/05/29/TCP%EC%99%80-IP/</url>
      <content type="text"><![CDATA[네트워크 용어  네트워크 : 컴퓨터끼리 정보를 주고 받을 수 있는 상태를 말한다.  프로토콜 : 국가끼리 문제없이 교류할 수 있도록 정해진 규칙  TCP/IP : 네트워크 상 송수신을 원할하게 수행하기 위한 규칙으로 데이터 송수신에 관한 일련의 작업을 하나로 모은 것  패킷    : 데이터 전송시 데이터를 일정 크기로 잘라서 보내는 방식으로, 보통 1 패킷 = 1024 비트이다.  cf) OSI 7 계층TCP/IP 작동 방식  [송신자 A] 애플리케이션 층 (HTTP, SMTP, POP3, FTP)          애플리케이션간 데이터를 주고받기 위해 필요한 정보를 작성한다.        [송신자 A] 트랜스포트 층 (TCP / UDP)          데이터를 패킷으로 나누고 애플리케이션을 나타내는 번호와 데이터 조합하기 위한 정보를 작성한다.        [송신자 A] 네트워크 층 ( IP )          송수신할 컴퓨터 주소와 불명인 경우 데이터를 파기하는 표시 등을 작성한다.        [송신자 A] 데이터링크 층 (Ethernet)          네트워크 종류에 맞춘 형식으로 수신지 정보 등을 작성한다.        [송신자 A] 물리 층          비트열을 신호로 변환해 전송한다.        [수신자 B] 물리 층          신호를 비트열로 변환한다.        [수신자 B] 데이터링크 층 (Ethernet)          헤더에 적힌 정보를 확인하고 지정된 프로토콜에게 전달한다.        [수신자 B] 네트워크 층 ( IP )          헤더에 적힌 수신처가 맞는지 확인하고 지정된 프로토콜에게 전달한다.        [수신자 B] 트랜스포트 층 (TCP / UDP)          헤더를 확인하고 데이터를 순서대로 나열해 조합한다.        [수신자 B] 애플리케이션 층 (HTTP, SMTP, POP3, FTP)          조합된 데이터를 확인한다.      애플리케이션 층  컴퓨터끼리의 주고받기를 사용자가 이용할 수 있는 ‘통신 서비스’ 형태로 만드는 것(서버/클라이언트)  애플리케이션 헤더 : 요청과 응답에 관한 정보가 들어있는 헤더  HTTP 프로토콜 : 하나의 요청에 하나의 응답을 반환하고 연결을 해제하는 방법  cf) HTTP 프로토콜과 Cookie/Session트랜스포트 층  애플리케이션 층과 네트워크 층의 중개 역할을 수행  TCP 프로토콜과 UDP 프로토콜이 존재한다.  cf) TCP/UDP 프로토콜 차이점네트워크 층  누가 누구에게 전달할 지를 결정하는 주요 역할, 적절한 루트를 사용해 전달하는 역할(Router)  IP 주소 : 인터넷 상의 컴퓨터들을 식별하기 위해 인터넷에 연결된 컴퓨터에 주어지는 숫자  IP 프로토콜 : 비커넥션형 프로토콜로 UDP와 동일하다. 신뢰성 있는 IP를 지원하기 위해 ICMP 프로토콜이 있다.  ICMP 프로토콜 : 수신인에게 전달되지 않는 등 문제 발생 시 송신자에게 그 사실을 알려주는 메세지를 전송한다.  IP 데이터그램 : 트랜스포트 층으로부터 데이터를 받아 IP 헤더를 붙인 것  Best Effort 방식 -&gt; 노력은 하지만 결과는 보장하지 않는다.데이터링크 층  데이터 링크 안에서 데이터를 어떻게 주고받을지 결정하는 역할  NIC(Network Interface Card)을 통해 비트열 &lt;-&gt; 신호 변환  NIC에는 MAC 주소라는 고유 번호가 할당되어 있어 MAC 주소가 일치하는 경우에만 수신자 NIC에서 데이터를 받는다.  수신인의 IP 주소만 알고 MAC 주소를 모르는 경우 ARP(Address Resolution Protocol) 프로토콜을 활용한다.          MAC 주소를 알고싶은 컴퓨터의 IP 주소를 ARP 패킷에 적고 브로드캐스트 MAC 주소 앞으로 보낸다.      자신의 IP 주소가 아니라면 파기하고, 자신의 IP 주소라면 MAC 주소를 적은 ARP 패킷을 송신자에게 보낸다.      &lt; CSMA 프로토콜 &gt;  동시에 네트워크를 사용하고자 할 때 상호충돌을 방지하고자 전송 Bus에 흐르는 신호를 감지하는 프로토콜을  즉, 노드 A에서 네트워크를 전송하기 전에 현재 채널을 사용 여부를 확인해 다중 접근을 방지하는 방법&lt; CSMA/CD &gt;  송신 전에 전송매체가 비어 있는지 확인하고(Carrier Sense), 비어 있으면 신호를 전송하고(Multiple Access), 전송 후에 충돌이 있는지 확인(Collision Detection) 하는 방식  데이터 프레임 간의 충돌이 발생하는 것을 보완하기 위해 CSMA 방식에 충돌 검증 + 재전송 기능 추가  모든 노드가 순서와 규칙 없이 경쟁하여 선로를 점유하는 방식으로 토큰 버스, 토큰 링은 각 노드에 차례로 점유할 기회를 주는 순차적 할당 방식  전송량이 적을 때 효율적이고 버스형 LAN에 가장 일반적으로 이용  송신하기 전에 송신중인 다른 노드가 없는지 조사한다.  MAC 주소 b 앞으로 데이터를 전송한다.  자기 앞으로 온 데이터일 경우 회수, 아닐 경우 파기한다.  충돌을 감지했을 때는 잠시 후 다시 전송한다.&lt;CSMA/CA &gt;  CSMA 방식 기반에 RTS와 CTS를 사전에 주고 받음으로써 전송할 시간을 미리 예약하여 충돌을 미연에 방지하는 방식]]></content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> Network </tag>
        
          <tag> TCP </tag>
        
          <tag> IP </tag>
        
          <tag> 프로토콜 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/10779 쇠막대기]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/29/%EB%B0%B1%EC%A4%80-10779-%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 쇠막대기 문제는 Stack 자료구조를 활용해 풀 수 있다.  입력 받은 문자열을 하나씩 탐색하면서 ‘(‘ 일때와 ‘)’로 나누어 생각한다.  ’(‘ 문자라면 Stack에 추가한다.  ’)’ 문자라면 바로 앞에 ‘(‘ 문자가 오는지 확인한다. (레이저인지 여부를 확인하기 위해)          만약 레이저라면 Stack 크기만큼 더해준다. (레이저로 나누면 Stack 크기만큼 레이저 왼쪽에 막대기가 생기기 때문!)      만약 막대기 끝이라면 막대기 갯수인 1개를 더해준다.    (끝부분 막대기를 더해준다)      &lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        char[] target = br.readLine().toCharArray();        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int ans = 0;        for (int i = 0; i &lt; target.length; i++) {            char ch = target[i];            if (ch == '(') {                stack.push(target[i]);                continue;            }            stack.pop();                //')' 문자 제거            if (target[i - 1] == '(') { //만약 레이저라면                ans += stack.size();    //레이저 왼쪽 막대 갯수를 더한다            } else {                    //막대의 끝이라면                ans += 1;               //자기 자신 막대를 더한다            }        }        System.out.println(ans);    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 10779 </tag>
        
          <tag> 백준 쇠막대기 </tag>
        
          <tag> Stack </tag>
        
          <tag> 스텍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[정렬 알고리즘]]></title>
      <url>/algorithm/2019/05/29/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</url>
      <content type="text"><![CDATA[버블 정렬(Bubble Sort)  인접한 두 숫자를 비교해서 변경하는 방법  오른쪽부터 최대값/최소값을 정렬해 나가는 방식public void BubbleSort(int[] num) {    for (int i = 0; i &lt; num.length; i++) {        for (int j = 1; j &lt; num.length - i; j++) {            if (num[j] &lt; num[j - 1]) swap(j - 1, j, num);        }    }}선택 정렬(Selection Sort)  자신보다 뒤에있는 숫자들 중 가장 작은 숫자를 발견해서 맨 앞에서부터 채우는 정렬  왼쪽부터 최대값/최소값을 정렬해 나가는 방식public void SelectionSort(int[] num) {    for (int i = 0; i &lt; num.length; i++) {        int min = i;        for (int j = i + 1; j &lt; num.length; j++) {            if (num[min] &gt; num[j]) min = j;        }        if (num[min] &lt; num[i]) swap(min, i, num);    }}삽입 정렬(Insertion Sort)  i번째 배열 값부터 앞으로 탐색하며 자신보다 작다면 swap하는 정렬  n번째 수행시 n번째 까지 정렬되는 방법public void InsertioinSort(int[] num) {    for (int i = 1; i &lt; num.length; i++) {        int tmp = num[i];        for (int j = i - 1; j &gt;= 0; j--) {            if (tmp &lt; num[j]) {                num[j + 1] = num[j];                num[j] = tmp;            }        }    }}퀵 정렬(Quick Sort)  pivot을 정하고 pivot 좌/우를 정렬하면서 전체 배열을 정렬  자바에서 Arrays.sort를 사용하변 내부는 Quick Sort로 구현되어있다.  평균 O(nlogn) 이지만 최악에 O(n^2) 이므로 데이터가 많은 경우 조심해야 한다.  최악의 경우란 아이러니하게도 정렬된 경우를 의미한다.&lt; 작동 방식 &gt;  pivot을 가운데 값으로 설정하고 Left, Right 를 각 끝의 idx를 지정한다.  num[left] &gt; pivot, num[right] &lt; pivot 조건을 만족할 때까지 left, right를 움직인다.  둘의 위치를 바꾼다. 이렇게 되면 pivot 왼쪽에는 pivot보다 작은 값, 오른쪽에는 큰값이 정렬된다.&lt; 소스 코드 &gt;public int partition(int left, int right, int[] num) {    int pivot = num[(left + right) / 2];    while (left &lt;= right) {        while (num[left] &lt; pivot) left++;        while (num[right] &gt; pivot) right--;        if (left &lt;= right) {            swap(left, right, num);            left++;            right--;        }    }    return left;} public void QuickSort(int left, int right, int[] num) {    if (left &lt; right) {        int pivot = partition(left, right, num);        if (left &lt; pivot - 1) QuickSort(left, pivot - 1, num);        if (right &gt; pivot) QuickSort(pivot, right, num);    }}합병 정렬(Merge Sort)  합병 정렬은 O(nlogn) 의 시간복잡도를 보장한다.  단점은 임시 배열 공간이 추가로 필요하다는 점이다.  분할 정복으로 구현하는데 배열을 최대한 나누고, 합병하면서 값을 비교해 정렬하는 방식이다.&lt; 작동 방식 &gt;  left = start, right = mid+1로 설정하고 서로 비교해 작은 값을 data에 덮어씌운다.  left를 한칸 이동하고 작은 값을 data에 덮어씌운다.  right를 한칸 이동하고 작은 값을 data에 덮어씌운다.  right가 배열의 끝에 도달했기 때문에 남은 left를 data에 덮어씌운다.&lt; 소스 코드 &gt;public void mergeSort(int start, int end) {    if (start &lt; end) {        int mid = (start + end) / 2;        mergeSort(start, mid);        mergeSort(mid + 1, end);        merge(start, mid, end);    }}public void merge(int start, int mid, int end) {    for (int i = start; i &lt;= end; i++) {        tmp[i] = num[i];    //tmp 배열에 값을 옮긴다.    }    int left = start;    int right = mid + 1;    int idx = start;    while (left &lt;= mid &amp;&amp; right &lt;= end) {        //num 배열에 비교하면서 저장        if (tmp[left] &gt;= tmp[right]) {            num[idx++] = tmp[right++];        } else {            num[idx++] = tmp[left++];        }    }    //어느 한쪽에 남은 tmp 배열을 num 배열에 저장    while (left &lt;= mid) num[idx++] = tmp[left++];    while (right &lt;= end) num[idx++] = tmp[right++];}]]></content>
      <categories>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> Algorithm </tag>
        
          <tag> Sort </tag>
        
          <tag> Bubble Sort </tag>
        
          <tag> Selection Sort </tag>
        
          <tag> Insertion Sort </tag>
        
          <tag> Quick Sort </tag>
        
          <tag> Merge Sort </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[데이터베이스 고급 기능]]></title>
      <url>/database/2019/05/29/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/</url>
      <content type="text"><![CDATA[트랜잭션&lt; 트랜잭션 정의 &gt;  한꺼번에 모두 수행되어야 할 일련의 연산들  병행 제어 및 회복 작업시 처리되는 작업의 논리적 단위  하나의 트랜잭션은 Commit / RollBack된다&lt; 트랜잭션 특징(ACID) &gt;  원자성(Automicity)    : Do or Nothing, 트랜잭션 내의 모든 명령은 완벽히 수행되거나 전부가 취소되어야 한다.  일관성(Consistency)   : 트랜잭션 실행이 성공적으로 완료되면 일관성 있는 데이터베이스의 상태는 일관되어야 한다.  독립성(Isolation)     : 어느 하나의 트랜잭션 실행중에 다른 트랜잭션 연산이 끼어들 수 없다.      지속성(Durability)    : 완료된 트랜잭션은 시스템의 고장나도 영구적으로 반영되어야 한다.    Commit 연산 : 한개의 트랜잭션에 대한 작업이 성공적으로 끝났고, 데이터베이스가 일관된 상태에 있을 때 이 트랜잭션이 수행한 연산이 완료됨을 알려주는 연산  Rollback 연산 : 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 수행한 모든 연산을 Undo하는 연산이다.병행제어 기법&lt; 병행제어의 목적 &gt;  데이터베이스 공유를 최대화한다.  시스템 활용도를 최대화한다.  데이터베이스 일관성을 유지한다.  사용자 응답 시간을 최소화한다.&lt; 로킹(Locking) 기법 &gt;  트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock을 요청해서 Lock이 허락되야 그 로킹 단위를 액세스 하는 기법  로킹 단위 : 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미하며 로킹의 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.  데이터를 갱신할 때 순서, 잠금(Lock) → 실행(Execute) → 해제(Unlock)                   공유 잠금      배타 잠금                  공유 잠금      접근 허용      대기              배타 잠금      대기      대기        공유 잠금(Shared-Lock) : 잠금 걸린 데이터에 대해 읽기 가능, 기록 불가능.  배타 잠금(Exclusive-Lock) : 잠금 걸린 데이터에 대해 읽기, 기록 모두 불가능.&lt; 2-단계 잠금 규약(Two-Phase Lock Protocol) 기법 &gt;  트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법― 확장(Growing) 단계 : 잠금만 수행할 수 있음. (해제 불가)― 축소(Shrinking) 단계 : 해제만 수행할 수 있음. (잠금 불가)  장점 : 직렬성 보장 / 단점 : 교착 상태 예방 불가능&lt; 타임 스탬프(Time Stamp Ordering) 기법 &gt;  시스템에 도착한 순서대로 타임 스탬프를 부여하여, 순서대로 실행하도록 한다.  교착 상태가 발생하지 않는다.무결성  데이터베이스의 저장된 데이터 값과 현실 세계의 실제값이 일치하는 정확성을 의미한다.  무결성 : 데이터의 정확성과 일관성을 유지하고 보증하는 것          고유 무결성 : 릴레이션의 특정 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다.      개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없다.      참조 무결성 : 외래키 값은 NULL 이거나 참조 릴레이션의 기본키 값과 동일해야 한다.      보안  데이터베이스의 일부분 또는 전체에 대해서 권한이 없는 사용자가 엑세스하는 것을 금지하기 위한 기술  데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대해 다른 접근 권리/권한을 갖게 된다.&lt; 암호화 기법 &gt;  개인키 암호 방식 = 대칭형 암호 알고리즘          동일한 키로 데이터 암호화/복호화 진행      수신자에게 키를 전달하는 방법                  Key를 비대칭형 암호 알고리즘을 이용하여 암호화 시킨 후 전송          실제 Key를 전송하지 않고도 A와 B가 동일한 Key를 생성할 수 있도록 하는 Diffie-Hellman 알고리즘을 사용하는 것                      공개키 암호 방식 = 비대칭형 암호 알고리즘          A는 공개키(public key)와 개인키(private key) 를 생성한다.                  A의 공개키를 이용하여 암호화된 데이터는 A의 개인키로만 복호화가 가능하다.          A의 개인키를 이용하여 암호화된 데이터는 A의 공개키로만 복호화가 가능하다.                    A와 B는 각자의 공개키를 서로에게 알려준다.                  A : 공개A키, 개인A키, 공개B키          B : 공개B키, 개인B키, 공개A키                    A는 B에게 데이터를 전송하기 위해 B의 공개B키를 이용하여 데이터를 암호화한 후 전송한다      암호화된 데이터는 개인B키를 가지고 있는 B만 해독할 수 있다.      &lt; 권한 부여 기법 &gt;  GRANT : 권한 부여 명령          GRANT 사용자 등급 TO 사용자 ID 리스트        REVOKE : 권한 취소 명령          REVOKE 사용자 등급 FROM 사용자 ID 리스트      분산 데이터베이스&lt; 분산 데이터베이스 정의 &gt;  논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 여러 개의 사이트에 분산되어 있는 데이터베이스  장점 : 자료의 공유성 향상, 시스템 성능 향상, 신뢰성 및 가용성이 높다  단점 : DBMS가 수행할 기능이 복잡, DB설계가 복잡, 소프트웨어 개발 비용이 증가]]></content>
      <categories>
        
          <category> Database </category>
        
      </categories>
      <tags>
        
          <tag> Database </tag>
        
          <tag> 트랜잭션 </tag>
        
          <tag> ACID </tag>
        
          <tag> 병행 제어 </tag>
        
          <tag> 무결성 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[관계 데이터베이스 모델과 언어]]></title>
      <url>/database/2019/05/28/%EA%B4%80%EA%B3%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%96%B8%EC%96%B4/</url>
      <content type="text"><![CDATA[관계형 데이터페이스 구조  릴레이션(Relation): 데이터베이스 테이블  튜플(Tuple)     : 릴레이션을 구성하는 각각의 행, 튜플의 수를 카디널리티라 부른다.  속성(Attribute) : 데이터베이스를 구성하는 가장 작은 논리적 단위  도메인(Domain)   : 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자들의 집합&lt; 릴레이션의 특징 &gt;  한 릴레이션에 포함된 튜플은 모두 다르다.  튜플 사이의 순서가 없고 삽입/삭제 등으로 인해 시간에 따라 변한다.  속성 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.관계형 데이터베이스 제약 조건  후보키 : 기본키로 사용할 수 있는 속성, 모든 튜플에 대해서 유일성과 최소성을 만족한다.          유일성 : 하나의 키 값으로 하나의 튜플을 유일하게 식별 가능해야 한다.      최소성 : 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성만으로만 구성되어야 한다.        기본키 : 후보키중 선택한 주 키로 NULL 값을 가질 수 없다.  대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 말한다.  외래키 : 관계를 맺고 있는 두 실레이션에서 한 릴레이션이 참조하고 있는 다른 릴레이션의 기본키와 같은 릴레이션의 속성을 말한다.  무결성 : 데이터의 정확성과 일관성을 유지하고 보증하는 것          개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없다.      참조 무결성 : 외래키 값은 NULL 이거나 참조 릴레이션의 기본키 값과 동일해야 한다.      관계 대수 및 관계 해석&lt; 관계 대수 &gt;  관계형 데이터베이스에서 원하는 정보와 어떻게 유도하는지 기술하는 절차적인 언어&lt; 관계 해석 &gt;  관계 데이터의 연산을 표현하는 방법으로 원하는 정보를 정의할 때는 계산 수식을 사용한다.  원하는 정보가 무엇인지만 정의하는 비절차적 특징을 지닌다.  튜플 관계해석과 도메인 관계해석이 있다.정규화&lt; 정규화 목적 &gt;  종속성 이론을 이용하여 잘못 설계된 관계셩 스키마를 더 작은 속성의 세트로 쪼개 바람직한 스키마로 만들어 가는 과정  데이터 구조의 안정성을 최대화해 중복성 및 종속성을 배제시키는 방법으로 사용한다.  효과적인 검색 알고리즘을 생성하고 중복을 배제해 삽입/삭제/갱신 이상의 발생을 방지한다.          삽입 이상 : 릴레이션에 데이터를 삽입할 때 의도와는 상관없는 원하지 않는 값들도 함께 삽입되는 현상      삭제 이상 : 릴레이션에 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상      갱신 이상 : 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상      &lt; 정규화 과정 &gt;  제 1정규형 : 다치가 존재하지 않는 릴레이션  제 2정규형 : 부분 함수적 종속성 x (기본키가 기본키가 아닌 속성에 종속 관계를 가짐)          R(A, B, C, D), A-&gt;C 일때 R1(A, C), R2(A, B, D)        제 3정규형 : 이행적 종속 관계 x (기본키가 아닌 속성이 다른 속성에 종속 관계를 가짐)          R(A,B, C, D), C-&gt;D 일때 R1(C, D), R2(A, B, D)        BCNF : 3 정규형에서 결정자이며 후보키가 아닌것 제거  cf) 종속 관계 : ‘학번’에 따라 ‘이름’이 결정될 때 ‘이름’을 ‘학번’에 함수 종속적이라 하며 ‘학번-&gt;이름’으로 표기한다.데이터베이스 언어  DDL(Data Definition Language)          DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용되는 언어      외부 스키마 명세를 정의하고 논리적/물리적 데이터 구조 정의      CREATE, ALTER, DROP, RENAME 등의 명령어를 사용한다.                  CREATE SCHEMA/DOMAIN/TABLE/INDEX 이름          ALTER TABLE 테이블이름 ADD/ALTER/DROP 속성이름          DROP SCHEMA/DOMAIN/TABLE/VIEW [CASCADE/RESCTRICTED]                      DML(Data Manipulation Language)          사용자가 데이터를 처리할 수 있게하는 도구로 사용자와 DBMS간의 인터페이스를 제공한다.      SELECT, INSERT, DELETE, UPDATE 등의 명령어를 사용한다.      SELCT ~ FROM ~ WHERE ~ GROUP BY ~ HAVING ~      INSERT ~ INTO ~ VALUES ~      DELETE ~ FROM ~ WHERE ~      UPDATE ~ SET ~ WHERE ~        DCL(Data Control Language)          무결성, 보안 및 권한 제어, 회복 등을 하기 위한 언어다.      GRANT(권한 생성), REVOKE(권한 삭제)      뷰(VIEW)  사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 유도된 가상 테이블이다.  물리적으로 저장장치에 존재하지 않지만 있는 것처럼 간주한다.  기본 테이블과 같은 구조를 가지며 조작도 기본 테이블과 거의 같다.  정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.      뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블을 기초로 정의된 다른 뷰도 삭제된다.    장점 : 접근 제어를 통한 자동 보안과 사용자 데이터를 간단하게 해준다.  단점 : ALTER VIEW로 정의를 변경할 수 없다. 삽입/삭제/갱신 연산에 제약이 따른다.시스템 카탈로그 (=데이터 사전)  시스템 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다.  데이터 객체에 대한 정의나 명세에 관한 정보를 유지/관리하는 시스템 테이블이다.  데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 접근 권한 등의 데이터베이스 구조 및 통계 정보를 저장한다.  카탈로그는 DBMS가 스스로 생성하고 유지한다.  시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색할 수 있다.  INSERT/DELETE/UPDATE 문으로 카탈로그를 갱신하는 것은 허용되지 않는다.]]></content>
      <categories>
        
          <category> Database </category>
        
      </categories>
      <tags>
        
          <tag> Database </tag>
        
          <tag> 관계형 데이터베이스 </tag>
        
          <tag> 정규화 </tag>
        
          <tag> 뷰 </tag>
        
          <tag> 시스템 카탈로그 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[데이터베이스 개념 및 모델링]]></title>
      <url>/database/2019/05/28/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EB%AA%A8%EB%8D%B8%EB%A7%81/</url>
      <content type="text"><![CDATA[데이터베이스 개념&lt; 데이터베이스 정의 &gt;  통합된 데이터 : 자료의 중복을 배제한 데이터의 모임  저장된 데이터 : 저장 매체에 저장된 자료  운영 데이터   : 조직의 고유 업무 수행을 위해 반드시 필요한 자료  공용 데이터   : 여러 응용 시스템들이 공동 소유하는 자료&lt; 데이터베이스 특징&gt;  실시간 접근성 : 실시간 처리에 대한 응답이 가능해야 한다.  계속적인 변화 : 데이터 삽입, 수정, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.  동시 공용     : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.  내용 참조     : 데이터를 참조시 사용자가 요구하는 데이터 내용으로 데이터를 찾는다.DBMS 기능&lt; DBMS 정의 &gt;  사용자와 데이터베이스 상에서 사용자의 요구에 따라 정보를 생성 및 관리해주는 소프트웨어  파일 시스템의 단점인 종속성, 중복성의 단점을 해결한다.&lt; DBMS 필수 기능 &gt;  정의(Definition) 기능          데이터베이스에 저장할 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능      데이터와 데이터 관계를 명확히 명세할 수 있어야 한다.        조작(Manipulation) 기능          데이터 검색/갱신/삽입/삭제 등을 체계적으로 처리하기 위해 사용자&lt;-&gt;데이터베이스 사이의 인터페이스 수단 제공        제어(Control) 기능          데이터의 무결성이 유지되어야 한다.      사용자별 허가된 데이터만 접근할 수 있도록 권한 검사를 수행한다.      여러 사용자가 데이터베이스를 동시에 접근해 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어를 수행해야 한다.      스키마  데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터 집합이다.  스키마는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 제약 조건에 전반적으로 정의한다.  외부 스키마          사용자가 각 개인의 입장에서 필요로 하는 데이터베이스 논리적 구조를 정의한 것      일반 사용자는 SQL을 이용해 DB를 쉽게 사용할 수 있다.        개념 스키마          데이터베이스의 전체적인 논리적 구조로 단순 스키마라고 하면 개념 스키마를 의미한다.      개체간의 관계와 제약조건, 접근권한, 보안 및 무결성 규칙에 관한 명세를 정의한다.        내부 스키마          물리적 저장장치의 입장에서 본 데이터베이스 구조로 시스템 설계자가 보는 관점의 스키마를 의미한다.      실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고 저장 데이터 표현 방법, 내부 레코드 물리적 순서 등을 나타낸다.      데이터 모델  개체(Entity) : 레코드에 대응하는 것으로 어떤 정보를 제공하는 역할 수행  속성(Attribute) : 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당&lt; E-R 모델 &gt;  개체와 개체간의 관계를 기본 요소로 이용하여 데이터를 개념적인 논리 데이터로 표현하는 방법데이터베이스 설계&lt; 데이터베이스 설계 고려 사항&gt;  무결성 : 삽입, 삭제, 갱신 등의 연산 후에도 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함  일관성 : 데이터베이스에 저장된 데이터들 사이나 특정 질의에 대한 응답이 처음부터 끝까지 일정해야 함  회복  : 시스템 장애가 발생시 장애 발생 직전 상태로 복구할 수 있어야 함  보안, 효울성, 데이터베이스 확장 등…&lt; 개념적 설계 &gt;  현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정  개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다.  요구 분석 단계에서 나온 결과를 DBMS에 독립적인 E-R 다이어그램으로 작성&lt; 논리적 설계 &gt;  현실 세계 자료를 컴퓨터가 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 논리적 구조로 변환시키는 과정  데이터 타입과 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화  개념 스키마를 평가 및 적재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계  트랜잭션 인터페이스 / 테이블 설계&lt; 물리적 설계 &gt;  논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정  데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다  저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 데이터가 저장되는 방법을 묘사한다.  저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등이 필수적으로 포함  기본적인 데이터 단위는 저장 레코드이며 여러 타입의 저장 레코드 집합이다  고려 사항 : 인덱스 구조, 레코드 크기, 레코드 개수, 트랜잭션 갱신과 참조 성향 등]]></content>
      <categories>
        
          <category> Database </category>
        
      </categories>
      <tags>
        
          <tag> Database </tag>
        
          <tag> 스키마 </tag>
        
          <tag> 데이터베이스 특징 </tag>
        
          <tag> 데이터베이스 설계 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/11004 K번째 수]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/27/%EB%B0%B1%EC%A4%80-11004-K%EB%B2%88%EC%A7%B8-%EC%88%98/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: K번째 수 문제는 MergeSort를 활용해 풀 수 있다.  범위가 500만이기 때문에 O(n^2) 시간복잡도로는 해결할 수 없다.      따라서 O(nlogn) 시간복잡도인 QuickSort와 MergeSort를 사용해야 하는데 평균 O(nlogn)인 MergeSort를 사용했다.    MergeSort 작동 방식          현재 배열 num과 임시 배열 tmp를 파라미터로 넘긴다.      start &lt; end 가 아닐 경우까지 쪼갠다.      다 쪼개졌다면 MergeSort 함수로 넘어간다.      num 배열을 tmp 배열에 옮긴다.      tmp 배열의 left, right 인덱스를 비교하면서 num 배열에 저장한다.      while문을 통해 남아있는 배열을 num 배열에 옮긴다.      &lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static int[] num, tmp;    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        stk = new StringTokenizer(br.readLine());        int n = Integer.parseInt(stk.nextToken());        int k = Integer.parseInt(stk.nextToken());        num = new int[n];        tmp = new int[n];        stk = new StringTokenizer(br.readLine());        for (int i = 0; i &lt; n; i++) {            num[i] = Integer.parseInt(stk.nextToken());        }        merge(0, n - 1);        System.out.println(num[k - 1]);    }    public static void merge(int start, int end) {        if (start &lt; end) {            int mid = (start + end) / 2;            merge(start, mid);            merge(mid + 1, end);            mergeSort(start, mid, end);        }    }    public static void mergeSort(int start, int mid, int end) {        for (int i = start; i &lt;= end; i++) {            tmp[i] = num[i];    //tmp 배열에 값을 옮긴다.        }        int left = start;        int right = mid + 1;        int idx = start;        while (left &lt;= mid &amp;&amp; right &lt;= end) {            //num 배열에 비교하면서 저장            if (tmp[left] &gt;= tmp[right]) {                num[idx++] = tmp[right++];            } else {                num[idx++] = tmp[left++];            }        }        //어느 한쪽에 남은 tmp 배열을 num 배열에 저장        while (left &lt;= mid) num[idx++] = tmp[left++];        while (right &lt;= end) num[idx++] = tmp[right++];    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 11004 </tag>
        
          <tag> 백준 K번째 수 </tag>
        
          <tag> 합병정렬 </tag>
        
          <tag> MergeSort </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[동원엔터프라이즈 인적성 후기]]></title>
      <url>/%EC%9D%B8%EC%A0%81%EC%84%B1/2019/05/27/%EB%8F%99%EC%9B%90%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88-%EC%9D%B8%EC%A0%81%EC%84%B1-%ED%9B%84%EA%B8%B0/</url>
      <content type="text"><![CDATA[&lt; 동원엔터프라이즈 인적성 후기 &gt;  5월 26일 잠실고등학교에서 동원엔터프라이즈 인적성을 보고 왔다.  자소서가 항목별 300자 쓰라고 하길래 붙을 줄 생각도 못하고있었는데 뜬금 합격.  오전/오후로 나누어져있는데 오후에 거의 900명가까이 됫으니 총 1800명정도? (계열사가 워낙 많지만)  입장시 로비에서 물이랑 GNC 비타민을 준다.&lt; 인성 검사 후기 &gt;  다른 기업과 달리 인성검사를 먼저 본다.  각 문항마다 매우아니다&lt;&gt;매우그렇다 로 선택한다.  다른 점은 4문항이 한 세트가 되어 가장 가깝다고 생각되는 것 하나와 가장 멀다고 생각되는 것 하나를 선택해야 한다.  인성검사치고 시간이 엄청 널널하지는 않다.&lt; 적성 고사 후기 &gt;  적성 고사는 언어, 수리, 상황판단, 상식 총 4개의 영역으로 구성되어 있다.  4 영역 모두 감점이 있기 때문에 찍을 수도 없다. 물론 상식은 좀 찍었지만..언어  지문이 엄청 길지는 않다. 평균적으로 시험지 한쪽에 2문제씩 나오는 정도?  4문제를 못풀었지만 언어 자신없는 내가 무난하다 느낄정도로 난이도가 평이했다.수리  꽤 어려웠다고 생각한다. 6문제 가량을 못풀었다.  계산도 중간중간 꼬이다보니 시간이 많이 걸렸는데 연산하다가 자료해석은 거의 구경도못했다.상황판단  이전 SKCT를 공부했던 경험이 있어서 별도로 공부는 진행하지 않았다.  큰 고민없이 25문제 전부 풀었다.상식  정말 모르면 답이없다.  찍으면 안되지만 어느정도 보고 찍었다.  최근 이슈랑 약어가 나오기 때문에 공부를 한다기보다 평소 자세히 봐야한다.  예를 들면 FAANG -&gt; WNSSS, 헌법 불합치, 대통령 권한, 디지털 디바이드, 학교폭력위원회 등 단순 공부로 할 수 있는 영역이 아니다.&lt; 결과 &gt;]]></content>
      <categories>
        
          <category> 인적성 </category>
        
      </categories>
      <tags>
        
          <tag> 인적성 </tag>
        
          <tag> 동원엔터프라이즈 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/1722 순열의 순서]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/26/%EB%B0%B1%EC%A4%80-1722-%EC%88%9C%EC%97%B4%EC%9D%98-%EC%88%9C%EC%84%9C/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 순열의 순서 문제는 직접 구하지 않고 수학적인 연산이 필요하다.  범위가 최대 20!이기 때문에 구하려고 들면 시간초과가 날 수 밖에 없다.  아이디어는 factorial 값을 저장해둔 배열을 하나 만들고 모듈러 연산을 한다.  만약 [3, 2, 4, 1] 배열이 있다고 했을 때 첫 번째가 4라면 [1, x, x, x], [2, x, x, x] 의 경우는 진행한 것으로 간주해 factorial[3] * 2 = 12 를 더한다.  이후 두 번째 숫자가 2라면 [3, 1, x, x]의 경우의 수는 전부 진행한 것으로 간주해 factorial[2] * 1 을 더한다.  k를 입력받을 때 1을 빼주는데 이유는 k 번째 다음 순열을 출력하기 때문이다.  factorial 배열, 입력받는 k 변수는 long 형으로 선언해야 한다. 범위를 초과하기 때문!&lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static int n;    public static long[] factorial;    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        n = Integer.parseInt(br.readLine());        int[] num = new int[n];        factorial = new long[n + 1];                //Factorial값 미리 구해서 저장        boolean[] isUsed = new boolean[n + 1];      //i번째 숫자 사용 여부        getFactorial();        stk = new StringTokenizer(br.readLine());        int type = Integer.parseInt(stk.nextToken());        if (type == 1) {            long k = Long.parseLong(stk.nextToken()) - 1;            for (int i = n; i &gt; 0; i--) {                long mod = k / factorial[i - 1] + 1;    //i번째에서 몇 번째 숫자를 선택할 지 구한다                k %= factorial[i - 1];                long cnt = 0;       //mod 번째 숫자를 찾기 위한 변수                int idx = 0;        //앞에서부터 해당 숫자를 확인할 때 사용하는 변수                while (cnt != mod) {                    idx++;                    if (!isUsed[idx]) cnt++;                }                isUsed[idx] = true;                sb.append(idx + " ");            }        } else {            long ans = 0;            for (int i = 0; i &lt; n; i++) {                num[i] = Integer.parseInt(stk.nextToken());                long cnt = 0;       //움직이는 횟수                int idx = 0;        //idx 숫자를 사용했는지 확인하는 변수                while (num[i] != idx) {                    idx++;                    if (!isUsed[idx]) cnt++;                }                isUsed[idx] = true;                ans += (cnt - 1) * factorial[n - i - 1];            }            sb.append(ans + 1);        }        System.out.println(sb);    }    public static void getFactorial() {     //factorial값 구하는 함수        factorial[0] = 1;        factorial[1] = 1;        for (int i = 2; i &lt;= n; i++) {            factorial[i] = factorial[i - 1] * i;        }    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 1722 </tag>
        
          <tag> 백준 순열의 순서 </tag>
        
          <tag> 스텍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/1541 잃어버린 괄호]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/25/%EB%B0%B1%EC%A4%80-1541-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 잃어버린 괄호 그리디하게 접근하면 해결할 수 있는 문제다.  boolean hasMinus 변수 하나를 만든다. 이 변수에는 ‘-‘가 입력받은 문자열에 존재하는 지를 확인한다.  만약 문자열에서 ‘-‘를 한번도 못 만낫다면 계속 숫자를 더한다.  만약 문자열에서 ‘-‘를 만나면 ‘-‘ 이후에 나오는 모든 숫자들은 빼도 된다. (‘+’ 연산은 괄호로 묶어 최대값으로 만들고 빼면 되니까)&lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static int curr, plus, ans;          //curr : +,- 연산 전의 숫자값 구하기, plus = curr값의 합    public static boolean hasMinus = false;     //입력받은 문자열에 '-'가 있는지 확인    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String target = br.readLine();        for (int i = 0; i &lt; target.length(); i++) {            char ch = target.charAt(i);            if (ch == '+') {                plus += curr;                curr = 0;            } else if (ch == '-') {                minusCal();                plus = 0;                curr = 0;            } else {                curr = curr * 10 + (ch - '0');            }        }        minusCal();        System.out.println(ans);    }    public static void minusCal() {        if (!hasMinus) {        //'-' 연산이 없다면 더한다.            plus += curr;            ans += plus;            hasMinus = true;        } else {                //'-' 연산이 있다면 ans값에 빼준다.            plus += curr;            ans -= plus;        }    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 1541 </tag>
        
          <tag> 백준 잃어버린 괄호 </tag>
        
          <tag> 스텍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[11번가 면접 후기]]></title>
      <url>/%EB%A9%B4%EC%A0%91/2019/05/23/11%EB%B2%88%EA%B0%80-%EB%A9%B4%EC%A0%91%ED%9B%84%EA%B8%B0/</url>
      <content type="text"><![CDATA[11번가 면접 후기  서울스퀘어 도착후 졸업예정서, 성적증명서 등 서류 제출  11번가 인턴 면접은 특이하게 PT 면접, 직무 면접, 코딩테스트 리뷰 3개로 나누어 진행한다.PT 면접 준비  도착하면 한 15분 정도 대기하다 옆 강의실로 이동한다.  40분동안 준비하고 5-10분정도 발표&amp;질문 받는다고 안내 받는다.  PT 관련 주제를 나눠주고 2개 주제 중 하나를 선택한다.  주제 하나는 배치 관련 질문이였고 선택한 주제는 11번가 검색창에서 어떤 상품을 검색하면 카테고리와의 유사도를 구하는 문제였다.  핸드폰이 사용가능하고 작성한 종이를 면접장에 가지고 간다.  40분이 지나고 나서 면접장으로 이동한다.면접 후기  면접이 조금 특이하게 2:1면접으로 40분이 진행되는데 순서가 정해져 있는것은 아니다.  면접관 재량에 따라 PT 발표했다가 코딩테스트 리뷰했다가 자소서 질문한다.&lt; 직무 면접 &gt;  입장하자마자 최대한 편하게 해주려고 하신다. 간단하게 회사 지원동기를 묻는다.          SI보다 서비스 개발이 하고싶다고 했다가 SI도 배울거 많다며 한소리 들었다.      트래픽 경험하고 싶다고 했다가 11번가는 중개자 역할로 고객이 판매자와 구매자가 있는데 판매자로 가면 어쩔건지 물어봣다가 털림        다른 지원자와 대비했을때 기술적인 강점이 뭐라고 생각하는지?          데이터베이스라고 했다가 처음들어보는 명령어 물어보길래 모른다고 답함      그럼 inner join과 outer join 설명해봐라 =&gt; 반대로 대답해서 또 한소리 들음        딥러닝 프로젝트 중 사이킷런 라벨링이 뭐한건지 설명 =&gt; 대답 못함  Spring 프로젝트 중 어떤걸 담당했고 어떤 기능을 개발했는지  REST는 직접 설계했는지&lt; PT 면접 &gt;  특정 검색어가 어떤 상품 카테고리와 연관성이 있는지 추출하는 시스템 설계하는 것이 주제  논리적/물리적 설계가 필요하다는데 제대로 이해 못함  TF-IDF 활용한다고 했더니 어떤 문서를 기준으로 할 것인지 물어봄  발표 중간중간 궁금한 점을 질문한다.  논리적/물리적 설계가 부족했는지 유스케이스나 데이터흐름을 그려달라고 했는데 여기서부터 막히기 시작  여기저기서 까이고 정신이 없었다.&lt; 코딩테스트 리뷰 &gt;  전공 면접 준비하는 시간에 다른 지원자들은 안주는데 나한테만 코딩테스트 준비하라고 코드를 뽑아줌(왜지?)  1번 문제는 100점이라 안물어봤는데 2,3번 코드 설명함  2번 문제는 당시에는 인덱스로 접근했지만 스텍으로 접근하면 될 것 같다고 말슴드림  3번 문제는 다익스트라랑 프림이랑 헷갈려서 틀렸다고 말씀드림  알고리즘 공부좀 한거같은데 만약 음수가 있다면 어떻게 할껀지? =&gt; 벨만포드 알고리즘을 활용할 것이라고 말씀드림      우선순위 큐에 대해서 설명해달라 하셔서 힙 정렬과 같이 말씀드림    마지막 질문한번 해보라고 하셔서 맥북을 쓰는거로 아는데 두 분다 삼성노트북을 사용하시길래 이유를 여쭤봄      백앤드/DBA/프론트 등 어떤 개발자가 되고 싶은지        정말 40분 면접 중에서 20분은 털린 듯.. 특히 PT 면접을 깊이 물어보셔서 답을 제대로 못한게 아쉽다.    면접비는 5월말에 통장으로 입금해주신다 했으니 아마 발표 시즌이랑 비슷하게 겹칠듯싶다.]]></content>
      <categories>
        
          <category> 면접 </category>
        
      </categories>
      <tags>
        
          <tag> 11번가 </tag>
        
          <tag> PT 면접 </tag>
        
          <tag> 코딩테스트 면접 </tag>
        
          <tag> 면접 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TCP/UDP란?]]></title>
      <url>/network/2019/05/22/TCP%EC%99%80-UDP/</url>
      <content type="text"><![CDATA[TCP((Transmission Control Protocol)  인터넷 상에서 데이터를 패킷 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다.  TCP와 IP를 함께 사용하는데, TCP는 발신지에서 수신지로 패킷을 전송하기 위한 논리적 경로를 배정한다.  연결형 서비스로 가상 회선 방식을 제공한다.          연결 시 3-way Handshaking 사용, 해체 시 4-way Handshaking 사용        흐름제어(송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다)  혼잡제어(네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것)  높은 신뢰성을 보장하지만 UDP보다 느린 속도를 가진다. ( 신뢰성 &gt; 속도 )&lt; TCP 작동 방식 &gt;  TCP 헤더에 6 비트의 컨트롤 플래그(Control Flag)를 활용한다. 상대에게 전하고 싶은 항목은 ‘1’로 만든다.&lt; 3-Way HandShake &gt;  TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정  TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.  A -&gt; B: SYN          접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)      송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.      PORT 상태 - B: LISTEN, A: CLOSED        B -&gt; A: SYN + ACK          접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)      수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.      PORT 상태 - B: SYN_RCV, A: CLOSED        A -&gt; B: ACK          PORT 상태 - B: SYN_RCV, A: ESTABLISHED      마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)      이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.      PORT 상태 - B: ESTABLISHED, A: ESTABLISHED      &lt; 4-Way HandShake &gt;  TCP의 연결을 해제(Connection Termination) 하는 과정  A -&gt; B: FIN          프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송      프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지        B -&gt; A: ACK          프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다. (이 상태가 TIME_WAIT 상태)      수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.      자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.        B -&gt; A: FIN          프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송        A -&gt; B: ACK          프로세스 A는 확인했다는 메시지를 전송      &lt; TCP Heaer &gt;UDP(User Datagram Protocol)  데이터를 데이터그램 단위로 처리하는 프로토콜, 데이터그램이란 독립적인 관계를 지니는 패킷  비연결형 프로토콜로 연결을 위한 논리적인 경로가 없다. 즉, 각각 다른 경로로 패킷을 전송하여 빠른 속도를 보여준다.  UDP Header의 CheckSum 필드를 통해 최소한의 오류만 검출한다.  흐름제어를 못하기 때문에 패킷이 재대로 전송 되었는지, 오류가 없는지 확인할 수 없다.  빠른 속도를 보여주지만 신뢰성이 없다. 스트리밍같은 서비스에 주로 사용된다.Reference  https://gmlwjd9405.github.io/2018/09/19/tcp-connection.html]]></content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> Network </tag>
        
          <tag> TCP </tag>
        
          <tag> 가상회선 패킷 </tag>
        
          <tag> UDP </tag>
        
          <tag> 데이터그램 패킷 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OSI 7 Layer란?]]></title>
      <url>/network/2019/05/22/OSI-7-Layer/</url>
      <content type="text"><![CDATA[OSI 7 Layer이란?  개방형 시스템 상호연결(Open System Intercon-nection, OSI) 모델  상호 이질적인 네트워크간의 연결에 어려움이 많은데 이러한 호환성의 결여를 막기위해 ISO(국제 표준화 기구)에서는 OSI 참조모델을 제시함  네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것네트워크 통신 과정을 7단계로 나눈 이유는?  계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다!  문제가 발생하더라도 해당 계층만 고치면 된다.OSI 7 Layer 구조1단계 : 물리 계층(Physical)  말 그대로 시스템의 물리적 표현을 나타낸다. (=물리적 장비)2단계 : 데이터 링크 계층 (Data Link)  노드 간 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다.  주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다. ex) 이더넷3단계 : 네트워크 계층(Network)  여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층  데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)  보스턴에 있는 컴퓨터가 캘리포니아에 있는 서버에 연결하려고 할 때 그 경로는 수백 만 가지다. 이 계층의 라우터가 이 작업을 효율적으로 처리한다.4단계 : 전송 계층(Transport)  양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.  전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)이다. 대표적인 예로 TCP가 있다.5단계 : 세션 계층(Session)  양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.  TCP/IP 세션을 만들고 없애는 책임을 진다.6단계 : 표현 계층(Presentation)  코드 간의 번역을 담당하여 사용자의 명령어를 완성 및 결과 표현한다.  데이터를 안전하게 전송하기 위해 암호화/복호화 하는 역할 수행7단계 : 응용 계층(Application)  HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.  사용자는 용도에 맞는 프로토콜을 선택하고 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. ex) MS Office, Chrome …OSI 7 Layer 쉽게 외우는 방법  CIOKorea에 나와있는 재미있는 방법  물리 계층에서 응용 계층까지(아래에서 위로)(P-D-N-T-S-P-A)  소시지 피자를 버리지 말아 주세요(Please-Do-Not-Throw-Sausage-Pizza-Away)참고  https://github.com/WeareSoft/tech-interview/  https://shlee0882.tistory.com/110  http://www.ciokorea.com/news/36536]]></content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> Network </tag>
        
          <tag> OSI 7 Layer </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HTTP와 REST API, Cookie, Session]]></title>
      <url>/network/2019/05/21/HTTP%EC%99%80-REST-API/</url>
      <content type="text"><![CDATA[HTTP(HyperText Transfer Protocol)이란?  인터넷에서 데이터를 주고받을 수 있는 프로토콜로 웹 서버와 클라이언트간 통신하기 위한 규약  어느 종류의 데이터든지 전송할 수 있도록 설계되어있다. HTML 뿐만아니라 이미지, 동영상, 오디오, 텍스트 문서 등 종류를 가리지 않는다.  이름 그대로 하이퍼텍스트를 기반으로 데이터를 전송하겠다는 말이다. 간단히 말하면 링크기반으로 데이터에 접속하겠다는 의미이다.HTTP 작동 방식  TCP/IP를 사용하는 응용 프로토콜이며 HTTP 메세지는 HTTP 서버와 HTTP 클라이언트가 해석한다.      HTTP는 연결 상태를 유지하지 않는 프로토콜이기 때문에 서버에 연결하고 Request에서 Response를 받으면 연결을 끊어버린다.    장점 : 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리 할 수 있다.  단점 : 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수 없다. 이를 위해 Cookie를 사용한다.  크롬 개발자도구의 네트워크 탭의 정보를 해석해보자.  요청한 URL은 http://sophia2730.tistory.com 이며 200 코드로 성공적인 요청이였다는 결과를 받았다.  여기서 작동한 Method는 GET이며 POST, PUT(수정) 등의 메소드를 사용하여 클라이언트와 서버가 데이터를 주고받는다.  여기서 URI를 자원으로 보고 Method를 동사로 보는 개발 방식이 REST 방식이다.REST API란?  웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일로, 자원을 표현으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.      즉, URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.    REST API는 두 가지 특징을 가진다.          URI는 정보의 자원을 표현해야 한다.  ex) GET /members/delete/1 (X),  DELETE /members/1 (O)      자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.      이러한 방식으로 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.Cookie와 SessionCookie  모든 내용이 클라이언트측에서 저장되며 서버에 요청할 때 마다 HTTP 헤더에 쿠키 내용(KEY=VALUE)을 전달합니다.  최초 접속일 경우 사용자ID, 로그인시간, IP등을 암호화한 구문을 클라이언트의 쿠키에 KEY=VALUE 된 구문으로 생성해 클라이언트에게 쿠키에 저장하라고 응답합니다. (예 : state=ASKHDNxxu7432keedsa7jhklsadasdmslk )  클라이언트는 매번 서버에 요청할 때 위 쿠키를 전달합니다.  서버는 로그인상황을 검사하기 위해서 매번 쿠키를 읽습니다. 그리고 위의 키를 찾아 정보를 해독하고, 서버에 있는 사용자 정보와 비교해 일치하면 로그인된 것으로 보고, 일치하지 않으면 불량요청 혹은 로그인하지 않은 사용자로 판별합니다.Session  Session은 서버쪽에 저장되는 쿠키이며 클라이언트가 서버에 Request를 보내면 서버는 클라이언트한테 세션 ID를 제공한다.  로그인 요청이 들어왔을 때 정보가 일치하면 서버는 사용자ID, 로그인시간, IP 등을 저장하는 Session을 생성합니다.  클라이언트에 응답할 때 세션을 찾을 수 있는 Session ID를 클라이언트에 전달합니다.(보통 쿠키로 전달)  클라이언트는 다음 요청시, Session ID를 함께 요청(쿠키를 사용하든 다른 방법을 사용하든)합니다.  서버가 요청을 받은 경우 Session ID를 이용해서 서버에 저장된 세션을 찾아와 로그인을 확인할 수 있습니다.Cookie와 Session의 저장 정보와 위치참고  https://message0412.tistory.com/entry/HTTP-프로토콜-알아보기1  https://hashcode.co.kr/questions/3243]]></content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> Network </tag>
        
          <tag> HTTP </tag>
        
          <tag> REST </tag>
        
          <tag> Cookie </tag>
        
          <tag> Session </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[주소창에 www.naver.com을 치면 일어나는 일]]></title>
      <url>/network/2019/05/21/www.naver.com%EC%9D%84-%EC%B9%98%EB%A9%B4-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC/</url>
      <content type="text"><![CDATA[주소창에 www.naver.com을 치면 일어나는 일  주소창에 www.naver.com을 입력하면 어떤 일이 일어날까?  면접 질문에서도 종종 나오는 이 방식은 생각보다 간단하다.  방식에 대해 이해하기 전에 IP 주소, 도메인에 대한 사전 지식이 필요하다.IP 주소  IP 주소란 많은 컴퓨터들이 인터넷 상에서 서로를 인식하기 위해 지정받은 식별용 번호라고 생각하면 된다.  현재는 IPv4 버전(32비트)로 구성되어 있으며 한번씩은 들어봤을 법한 127.0.0.1 같은 주소를 말한다.  시간이 갈수록 IPv4 주소의 부족으로 IPv6가 생겼는데, 128비트로 구성되어있기 때문에 IP 주소가 부족하지 않다는 특징이 있다.도메인 네임(Domain Name)  IP주소는 12자리의 숫자로 되어있기 때문에 사람이 외우기 힘들다는 단점이 있다.  그렇기 때문에 12자리의 IP 주소를 문자로 표현한 주소를 도메인 네임이라고 한다.  다시 말해서, 도메인 네임은 ‘naver.com’처럼 몇 개의 의미있는 문자들과 점(.)의 조합으로 구성된다.  도메인 네임은 사람의 편의성을 위해 만든 주소이므로 실제로는 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 작업이 필요하다.  이때 사용할 수 있도록 미리 도메인 네임과 함께 해당하는 IP 주소값을 한 쌍으로 저장하고 있는 데이터베이스를 DNS(Domain Name System) 이라고 부른다.  다시 말해 사람이 도메인 네임으로 입력하면 DNS를 이용해 컴퓨터는 IP 주소를 찾아갈 수 있다.WEB 동작 원리  사용자가 브라우저에 도메인 네임(www.naver.com)을 입력한다.  사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.  페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.  이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.  검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.  도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.어려운 개념은 아니니 재미삼아 읽어봐도 좋을 것 같다.출처 : http://tcpschool.com/webbasic/works]]></content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> Network </tag>
        
          <tag> IP 주소 </tag>
        
          <tag> DNS </tag>
        
          <tag> 도메인 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ArrayList와 LinkedList]]></title>
      <url>/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2019/05/21/ArrayList%EC%99%80-LinkedList/</url>
      <content type="text"><![CDATA[ArrayList와 LinkedList  ArrayList와 LinktedList 둘다 모두 Java에서 제공하는 List 인터페이스를 구현한 Collection 구현체이다.  하지만 내부적으로 작동하는 방식은 다르다.import java.io.*;import java.util.*; public class Main {    public static void main(String[] args) throws Exception {        ArrayList&lt;String&gt; alist = new ArrayList&lt;&gt;();        alist.add(0,"First");           //O(1)        alist.add("Third");             //O(1)        alist.add(1, "Second");         //O(n)        alist.remove(1);                //O(n)         alist.get(1);                   //O(1)         LinkedList&lt;String&gt; nlist = new LinkedList&lt;&gt;();        nlist.addFirst("First");        //O(1)        nlist.add("Second");            //O(1)        nlist.addLast("Third");         //O(1)        nlist.pollFirst();              //O(1)        nlist.pollLast();               //O(1)         nlist.get(0);                   //O(n)    }}ArrayList  알고리즘 문제를 풀면서 가장 중요한 ArrayList와 LinkedList의 차이점은 시간복잡도의 차이라고 볼 수 있다.  ArrayList는 동적으로 Array를 생성한다고 생각하면 배열과 비슷한 점이 많다.  ArrayList는 remove 시에 O(n)의 시간복잡도를 가진다.  i번째 배열을 지우고 최대 n만큼 앞으로 이동해야 하기 때문이다.&lt; ArrayList 중간 Insert &gt;&lt; ArrayList 중간 Remove &gt;  삽입 또한 맨 뒤에삽입과 중간삽입으로 나눌 수 있는데, 중간에 삽입하는 경우 O(n), 맨 뒤에 삽입하는 경우 O(1)의 시간복잡도를 가진다.  하지만 get 메소드는 해당 index를 바로 가져오기 때문에 O(1)의 시간복잡도를 가진다.LinkedList&lt; LinkedList 중간 add &gt;  이에 비해, LinkedList는 Node를 사용하기 때문에 add, poll 시에 O(1)의 시간복잡도를 가진다.  하지만 get 메소드 사용시에 앞에서부터 찾기 때문에 O(n)의 시간복잡도를 가진다.정리                   ArrayList      LinkedList                  삽입      addO(1) or O(n)      add, addFirst, addLastO(1)              삭제      removeO(n)      poll, pollFirst, pollLastO(1)              접근      getO(1)      getO(n)      ]]></content>
      <categories>
        
          <category> 자료구조 </category>
        
      </categories>
      <tags>
        
          <tag> 자료구조 </tag>
        
          <tag> ArrayList </tag>
        
          <tag> LinkedList </tag>
        
          <tag> 시간복잡도 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[기억장치 관리]]></title>
      <url>/os/2019/05/20/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/</url>
      <content type="text"><![CDATA[기억장치 배치 전략  최초 적합(First Fit) : 가능한 영역 중에서 첫 번째 분할 영역에 배치시키는 방법  최적 적합(Best Fit)  : 가능한 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치하는 방법  최악 적합(Worst Fit) : 가능한 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치하는 방법            영역번호      영역크기      상태                  1      5K      공백              2      14K      공백              3      10K      사용중              4      12K      공백              5      16K      공백      배치 전략 중 10K 프로그램이 할당 받는 영역의 번호는 다음과 같다.  최초 적합(First Fit) : 10K 프로그램이 들어갈 수 있는 첫 번째 영역은 2번이다.  최적 적합(Best Fit)  : 10K 프로그램이 들어가고 단편화를 가장 작게 남기는 영역은 4번이다.  최악 적합(Worst Fit) : 10K 프로그램이 들어가고 단편화를 가장 많이 남기는 영역은 5번이다.가상기억장치 구현  보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸눈 주소 변환 작업(매핑)이 필요하다.  페이징 기법 : 프로그램을 동일한 크기로 나눈 단위를 페이지라 하며 이 페이지를 블록으로 활용하는 기법      세그먼테이션 기법 : 프로그램을 가변적인 크기로 나눈 단위를 세그먼트라 하며, 이 세그먼트를 블록으로 사용하는 기법    내부 단변화 : 프로그램이 할당된 후 남는 빈 공간, 영역 크기 16K &gt; 프로그램 크기 14K 인 경우 내부 단편화 2K 발생  외부 단편화 : 영역 크기보다 프로그램 크기가 커서 할당되지 않아 남는 빈 공간, 영억 크기 12K &lt; 프로그램 크기 14K 인 경우 외부 단편화 2K 발생페이징 기법  페이지 : 프로그램을 일정한 크기로 나눈 단위(일반적으로 1~4KB)  프레임 : 페이지 크기로 일정하게 나누어진 주기억장치 단위  주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.  외부 단편화는 발생하지 않지만 내부 단편화는 발생할 수 있다.  장점 : 여러 개의 프로그램을 동시 실행할 수 있어 다중 프로그래밍 정도가 향상된다.  단점 : 주소 변환 과정에서 CPU 사용시간이 낭비되고 내부 단편화 문제가 발생한다.세그먼테이션 기법  세그먼트 : 사용자 주소 공간을 논리적인 단위로 나눈 것, 각 세그먼트는 고유한 이름과 크기를 가진다.  주소 변환을 위해 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다.  장점 : 외부단편화에 의한 기억장치 낭비를 줄일 수 있다.  단점 : 세그먼트 크기가 가변적이기 때문에 세그먼트 영역이 다른 세그먼트 영역을 침범하지 않는 기억장치 보호키가 필요하다.페이지 교체 알고리즘  페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재하는 데 어떤 프레임을 선택해 교체할 지 결정하는 기법FIFO(First In First Out)  가장 오래 있었던 페이지를 고체하는 기법이다.  벨레이디의 모순 현상이 발생한다.(프레임 수가 늘어나면 페이지 부재 수가 줄어들지 않는 현상)            참조 페이지      1      2      3      4      1      2      5      1      2      3      4      5                  Frame 1      1      1      1      4      4      4      5      5      5      5      5      5              Frame 2             2      2      2      1      1      1      1      1      3      3      3              Frame 3                    3      3      3      2      2      2      2      2      4      4              페이지 부재      O      O      O      O      O      O      O                    O      O               위 경우 페이지 부재가 총 9번 발생한다.  하지만, Frame 개수가 4개로 늘어나도 페이지 부재는 10번으로 증가한다. =&gt; 벨레이디 모순 현상LRU(Least Recently Used)  최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법  계수기나 스택같은 별로 하드웨어가 필요하며 시간적인 오버헤드가 발생하고, 실제로 구현하기 어렵다.            참조 페이지      2      3      2      1      5      2      3      5                  Frame 1      2      2      2      2      2      2      2      2              Frame 2             3      3      3      5      5      5      5              Frame 3                           1      1      1      3      3              페이지 부재      O      O             O      O             O             LFU(Least Frequently Used)  사용 빈도가 가장 적은 페이지를 교체하는 기법  활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.  초기에 많이 사용된 페이지가 그 후루도 사용되지 않을 경우 프레임을 계속 차지할 수 있다.            참조 페이지      2      3      1      3      1      2      4      5                  Frame 1      2      2      2      2      2      2      2      2              Frame 2             3      3      3      3      3      3      3              Frame 3                    1      1      1      1      1      1              Frame 4                                                4      5              페이지 부재      O      O      O                           O      O      가상기억창치 관리  페이지 크기          페이지 크기가 작을 경우                  페이지 단편화가 가모되고 볼필요한 내용이 주기억장치에 적재될 확률이 적다.          페이지 정보를 가지는 페이지 맵 테이블 크기가 커지고 매핑 속도가 늦어진다.          디스크 접근 횟수가 많아져 전체적인 입출력 시간이 증가한다.                    페이지 크기가 클 경우                  페이지 정보를 갖는 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.          디스크 접근 횟수가 줄어들어 전체적인 입출력 시간이 감소한다.          페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.                      구역성(Locality)          어느 순간 특정 페이지만 집중적으로 참조하는 것      시간 구역성                  하나의 페이지를 일정 시간 동안 집중적으로 엑세스하는 현상          한번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높다.                    공간 구역성                  어느 하나의 페이지를 참조하면 그 근처의 페이지를 참조할 가능성이 높다.          프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상                      워킹 셋(Working Set)          프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합      자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 교체 현상이 줄어들어 사용이 안정화된다.        스레싱(Thrashing)          프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상      어떤 프로세스가 실제로 사용하는 프레임 수만큼의 프레임을 갖지 못한 경우 발생      방지 방법 : 다중 프로그래밍 정도 완화, Working Set 이용      cf) 다중 프로그래밍 정도 : 얼마나 많은 프로그램을 동시에 수행하는 정도      디스크 스케줄링  사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우 디스크 헤드가 움직으는 경로를 결정하는 기법  목적 : 처리량 최대화, 응답 시간 최소화, 응답 시간 편차의 최소화FCFS(First Come First Service)  디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법  더 높은 우선순위의 요청이 입력되어도 순사가 바뀌지 않아 공평성이 보장된다.  디스크 오버헤드가 적을 때 효율적이며, 오버헤드가 커지면 응답 시간이 길어진다.  디스크 대기 큐 : 53,98,183,37,122,14,124,65,67  이동 순서 : 53 -&gt; 98 -&gt; 183 -&gt; 37 -&gt; 122 -&gt; 14 -&gt; 124 -&gt; 65 -&gt; 67SSTF(Shortest Seek Time First)  탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법  현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동한다.  현재 헤드 위치에 가장 가까운 트랙에 대한 요청이 계속 발생하는 경우 먼 거리의 서비스는 무한정 기다리는 기아 상태가 발생할 수 있다.  디스크 대기 큐 : 53,98,183,37,122,14,124,65,67  이동 순서 : 53 -&gt; 65 -&gt; 67 -&gt; 37 -&gt; 14 -&gt; 98 -&gt; 122 -&gt; 124 -&gt; 183SCAN  SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법  현재 헤드 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스 후 역방향의 요청 사항을 서비스한다.  오버헤드가 적을 경우 가장 효율적인 기법이다.  디스크 대기 큐 : 53,98,183,37,122,14,124,65,67  이동 순서 : 53 -&gt; 65 -&gt; 67 -&gt; 98 -&gt; 122 -&gt; 124 -&gt; 183 -&gt; 199 -&gt; 37 -&gt; 14C-SCAN(Circular SCAN)  항상 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법  처음가 마지막을 인접시킨 것과 같은 원형 형태로 디스크를 처리한다.  디스크 대기 큐 : 53,98,183,37,122,14,124,65,67  이동 순서 : 53 -&gt; 37 -&gt; 14 -&gt; 0 -&gt; 199 -&gt; 183 -&gt; 124 -&gt; 122 -&gt; 98 -&gt; 67 -&gt; 65]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
          <tag> 기억장치 </tag>
        
          <tag> 메모리 할당 </tag>
        
          <tag> 페이징 </tag>
        
          <tag> 세그먼테이션 </tag>
        
          <tag> 디스크 스케쥴링 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[프로세스 동기화]]></title>
      <url>/os/2019/05/19/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/</url>
      <content type="text"><![CDATA[프로세스 동기화 배경  프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성이 유지되어야 한다.  병행 프로세스는 다중 처리 시스템이나 분산 처리 시스템에서 중요 개념으로 사용임계 구역  임계구역 안에서는 공유 변수를 변경, 테이블 갱신, 파일 쓰기 등의 작업을 수행한다.  임계구역에는 하나의 프로세스만 접근할 수 있으며, 해당 프로세스가 자원을 반납해야 다른 프로세스가 자원 및 데이터를 사용할 수 있다.  한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다.임계구역 문제 해결 방법  상호 배제 기법          특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법      두 개의 프로세스 기준 : 피터슨 알고리즘(두 프로세스가 두 개의 데이터 항목을 공유하여 자원을 사용하는 방법)      여러 개의 프로세스 기준 : Lamport의 빵집 알고리즘(각 프로세스에 번호를 부여하여 자원을 사용하도록 하는 방볍)        진행          자신의 임계구역에서 실행되는 프로세스가 없고 자신의 임계구역으로 진입하려는 프로세스가 있다면 잔류 구역에서 실행 중이지 않은 프로세스들만 임계영역에 진입 대상이 되고, 이 선택은 무한정 연기되지 않음!        한계 대기          프로세스가 자기의 임계구역에 진입하려는 요청을 한 후로부터 요청이 허용될 때까지 다른 프로세스들이 임계영역에 그들 자신의 임계구역에 진입을 허용하는 횟수의 한계가 필요하다.      Mutex Lock(상호 배재)  Mutex가 지켜주는 덕에 화장실을 한명만 사용할 수 있다.  즉, Mutex는 임계구역을 보호하고 프로세스간 경쟁을 방지하기 위해 사용  boolean available 변수를 사용 =&gt; 락의 가용 여부 표시do {    //Lock 획득    임계구역    //Lock 반환    나머지 구역} while(true);세마포어(Semaphore)  Mutex와 유사하게 동작하지만 프로세스들이 자신들의 행동을 더 정교하게 동기화 할 수 있는 방법 제공  각 프로세스에 제어신호를 전달하여 순차적으로 진행하기 위한 동기화 구현  세마포 S = 정수 변수, wait(s)와 signal(s)로만 접근이 가능하다. S = 0인 경우 모든 자원이 사용 중을 의미//wait(S) =&gt; 상호배재 보장//임계구역에 진입하기 전에 확인if (S &lt;= 0) //누군가 사용하고 있다면    S가 양수가 될 때까지 현재 프로세스를 list에서 기다림else    //임계 구역에 진입이 가능하다면    S = S - 1;//Signal(S) =&gt; 진행 보장//임계구역을 떠날 때 실행if (자원 반환전에 list에서 기다리는 프로세스가 있다면)    그 중 한개 프로세스를 임계 구역 진입else     //list에서 기다리는 프로세스가 없다면    S = S + 1;Mutex와 세마포어의 차이Mutex(상호 배재)  Critical Section을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술  Mutex 객체를 두 쓰레드가 동시에 사용할 수 없다. (1개의 쓰레드만 Critical Section에 접근 가능하도록 하는 기술)  cf) Critical Section : 각 프로세스에서 공유데이터를 엑세스하는 프로그램 코드부분세마포어(Semaphore)  공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것  만약, 화장실 칸이 4개라면 4개의 프로세스는 사용 가능하고, 나머지 프로세스는 대기해야 한다.고전적인 동기화 문제  생산자-소비자 문제          생산자가 데이터를 생산하여 입력된 경우에만 접근하도록 구성하는 방식      생산자는 꽉찬 버퍼를 생산하고 소비자는 비어있는 버퍼를 생산한다.        읽기-쓰기 문제          두 Reader가 동시에 공유 데이터를 접근하는 것은 허용하나, 동시에 Writer를 허용하지 않는 방식      Writer보다 Reader 요청이 많은 경우 병행성을 높일 수 있다.        식사하는 철학자 문제          5명의 철학자들은 생각하고 먹는 일을 수행(철학자 : 프로세스, 젓가락 : 자원)              철학자는 양쪽의 젓가락을 사용하여 식사를 하고, 식사를 마친 철학자는 젓가락을 내려놓고 다시 생각한다.      철학자는 2개의 젓가락을 손에 쥐어야 식사를 할 수 있고, 한 번에 하나씩 잡을 수 있다.      옆 사람이 식사중이면 젓가락 잡는 것을 대기한다.      5명의 철학자가 동시에 식사를 하게 되면 모두 왼쪽 포크만을 가지게 되고 오른쪽 포크를 대기하는 교착 상태(Deadlock)이 발생한다.이를 방지하기 위한 방법은 대표적으로 3가지이다.  최대 4명의 철학자들만이 테이블에 앉을 수 있도록 한다. =&gt; 젓가락이 하나 남기 때문에 어떤 철학자는 식사가 가능하다.  한 철학자가 동시에 두개의 젓가락을 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.(즉, 임계구역 안에서만 젓가락을 집어야 한다)  비대칭 해결안을 사용한다.(홀수 번 철학자는 왼쪽, 짝수 번 철학자는 오른쪽 젓가락부터 집는다)교착상태(DeadLock)  상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상예방 기법  상호 배재 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.  점유 및 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당해 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다.  비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구 자원을 사용하기 위해 기다리게 한다.  환형 대기 부정 : 자원을 선형 순서로 분류해 고유 번호를 할당하고, 각 프로세스는 현재 점유한 고유 번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 한다.회피 기법(Dijkstra 제안한 은행원 알고리즘)  안정 상태 : 모든 프로세스가 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태  불안정 상태 : 교착상태의 필수 조건으로 교착상태가 발생할 수 있는 상태은행원 알고리즘 : 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘  각 프로세스마다 할당할 수 있는 최대 자원을 계산한다.  각 프로세스마다 자원을 할당한 후에도 안전 상태를 유지할 수 있는지 확인하고 자원을 할당한다.  추가적인 자원을 할당해도 안전 상태를 유지할 수 있다면 자원을 할당할 수 있다. 하지만 불안전상태가 된다면 교착상태가 되므로 거절한다.  Available : 각 종류별로 가용한 자원의 개수, Available[i] = k 라면 R[i] 를 K개 사용할 수 있다는 뜻  Max : 각 프로세스가 최대로 필요로 하는 자원의 개수, Max[i,j] = k 라면 Process[i]가 R[j]를 K개까지 요청할 수 있다는 뜻  Allocation : 각 프로세스에게 현재 나가있는 자원의 개수, Allocation[i,j] = k 라면 현재 Process[i]가 R[j]를 K개 사용 중이라는 뜻  Need : 각 프로세스가 향후 요청할 수 있는 자원의 개수, Need[i,j] = k라면 Process[i]가 향후 R[j]를 K개 요청할 수 있다는 뜻          Need = Max - Allocation      자원 요청 알고리즘  만약 Request[i] &lt;= Need[i] 이면 2단계로 이동, 아니면 시스템에 있는 개수보다 더 많이 요청했기 때문에 오류로 처리  만약 Request[i] &lt;= Available[i] 이면 3단꼐로 이동, 아니면 요청한 자원이 지금 없으므로 Process[i]는 기다려야 한다.  Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다.          Available = Available - Request[i]      Allocation[i] = Allocation[i] + Request[i]      Need[i] = Need[i] - Request[i]        만약, 이렇게 바뀐 상태가 안전하다면 Process[i]에게 자원을 할당한다. 그렇지 않다면 상태를 원상태로 되돌리고 Request[i]가 만족될 때까지 기다린다.예를 통해 알아보자. 프로세스 P와 A 자원 10개, B 자원 5개, C 자원 7개가 있을 때 다음과 같은 예시가 있다고 가정하자.            Process             Allocation                    Max                    Need                         Type      A      B      C      A      B      C      A      B      C              P[0]      0      1      0      7      5      3      7      4      3              P[1]      2      0      0      3      2      2      1      2      2              P[2]      3      0      2      9      0      2      6      0      0              P[3]      2      1      1      2      2      2      0      1      1              P[4]      0      0      2      4      3      3      4      3      1      Need 값은 Max - Allocation 으로 구할 수 있으며 이 경우 남은 자원 수는 다음과 같다.                   Available                         A      B      C              10 - (0+2+3+2+0) = 3      5 - (1+0+0+1+0) = 3      7 - (0+0+2+1+2) = 2      여기서 P[1]이 A 자원 1개와 C 자원 2개를 추가로 요청한다고 가정해보자. 이 때의 Request[1] = (1,0,2) 가 된다.  Request[i] &lt;= Need[i]를 검사한다. (1,0,2) &lt;= (1,2,2)이므로 조건을 만족한다.  Request[i] &lt;= Available[i]를 검사한다. (1,0,2) &lt;= (3,3,2) 이므로 조건을 만족한다.  Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다.          Available[1] = Available[1] (3,3,2) - Request[1] (1,0,2) = (2,3,0)      Allocation[1] = Allocation[1] (2,0,0) + Request[1] (1,0,2) = (3,0,2)      Need[1] = Need[1] (1,2,2) - Request[1] (1,0,2) = (0,2,0)        위 상태는 안정 상태이므로 Process[1] 의 요청을 즉시 들어줄 수 있다.위 예시에서는 &lt;P[1], P[3], P[4], P[2], P[0]&gt; 순서로 진행하면 안정 순서열이 된다.]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
          <tag> 프로세스 동기화 </tag>
        
          <tag> Mutex </tag>
        
          <tag> Semaphore </tag>
        
          <tag> 뮤텍스 </tag>
        
          <tag> 세마포어 </tag>
        
          <tag> 데드락 </tag>
        
          <tag> 은행원 알고리즘 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[운영체제와 CPU 스케쥴링]]></title>
      <url>/os/2019/05/19/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/</url>
      <content type="text"><![CDATA[운영체제란?  제한된 컴퓨터 각종 자원을 효율적으로 관리하여 사용자에게 편리한 환경을 제공하는 소프트웨어운영체제 목적  처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양  반환 시간 : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 소요되는 시간  사용 가능도 : 시스템 사용할 필요가 있을 때 즉시 가용 가능한 정도  신뢰도 : 시스템이 주어진 문제를 정확하게 해결하는 정도운영체제 기능  프로세서 관리  기억장치 관리  프로세스 관리  주변장치 관리  파일 및 데이터 관리프로세스  현재 실행중이거나 곧 실행 가능한 PCB를 가진 프로그램  PCB(Process Control Block) : OS가 프로세스의 대한 중요한 정보를 저장하는 곳으로 각 프로세스가 생성될 때 고유 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.스레드(Thread)  프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위  스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스 역할 담당  하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.  공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.CPU 스케줄링  프로세스가 생성되어 실행될 때 필요한 시스템의 자원을 해당 프로세스에 할당하는 것          cf) 문맥 교환(Context Switching) : 하나의 프로세스에서 다른 프로세스로 전환할 때 실행하던 프로세스의 상태를 보관하고 새로운 프로세스 정보를 적재하여 실행을 준비하는 것      cf) 준비상태 큐(Ready Queue) : 주기억장치에 적재되어 있으면서 CPU에 의해 실행되기를 준비하는 프로세스들로 구성된 리스트      비선점 스케쥴링  이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법  프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.  프로세스의 요구를 공정하게 처리할 수 있지만 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생한다.FCFS(First Come First Service)  준비상태 큐에 먼저 도착한 순서대로 CPU에 할당하는 기법  공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 된다.SJF(Short Job First)  준비상태 큐에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법  실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 할당 순위가 밀려 무한 연기(기아) 상태가 발생할 수 있다.HRN(Hightest Response-ratio Next)  SJF 기법을 보완한 것으로 대기 중인 프로세스들의 대기시간과 실행시간을 고려하여 우선순위를 결정한다.  우선순위 계산식 : (대기시간 + 수행시간) / 수행시간선점 스케쥴링  하나의 프로세스가 CPU를 할당받아 실행중일 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케쥴링 기법  우선순위가 높은 프로세스를 빠르게 처리할 수 있지만 많은 Overhead를 초래한다.Round  Robin  각 프로세스느 시간 할당량(Time Slice)만큼 CPU를 점유하고 실행이 완료되지 않으면 CPU를 반환하고 준비상태 큐의 가장 뒤로 배치  문맥 교환(Context Switching) 효과를 고려하여 시간 할당량을 정한다.  시간 할당량이 클수록 FCFS와 같아지고, 시간 할당량이 작을 수록 문맥 교환 및 오버헤드가 자주발생SRT(Shortest Remaining Time)  SJF 기법을 선점 형태로 변경한 기법으로 프로세스들 중 남아있는 실행시간이 가장 짧은 프로세스를 다음 프로세스로 선택다단계 큐 스케쥴링  준비완료 큐를 다수의 별도의 큐로 분리하여 각 큐의 독자적인 스케쥴링에 따라 CPU를 할당받는 기법  각각의 서로 다른 작업들이 다른 묶음으로 분리될 수 있을 때 사용한다.  이전 작업이 실행 중이더라도 우선 순위가 높은 큐에 작업이 들어오면 CPU를 반환해야 한다.          cf) 우선순위 : 시스템 프로세스 &gt; 대화형 프로세스 &gt; 일괄처리 프로세스      다단계 피드백 큐 스케쥴링  프로세스가 큐들 사이를 이동하는 것을 허용하는 기법이다.  프로세스를 CPU 성격에 따라 구분하고 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 한 단계 낮은 우선순위 준비큐로 강등된다.  즉, 짧은 프로세스의 경우 FCFS 방식으로 신속하게 실행되고, 긴 프로세스는 낮은 단계의 준비단계 큐로 밀린다.  낮은 우선순위 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동한다. (Aging 기법) -&gt; 기아 상태 예방]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
          <tag> 프로세스 </tag>
        
          <tag> 스레드 </tag>
        
          <tag> 비선점 스케쥴링 </tag>
        
          <tag> 선점 스케쥴링 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Stack 영역과 Heap 영역]]></title>
      <url>/java/2019/05/19/Stack-%EC%98%81%EC%97%AD%EA%B3%BC-Heap-%EC%98%81%EC%97%AD/</url>
      <content type="text"><![CDATA[Stack 영역  메소드 지역 변수를 Stack 형식으로 임시 할당하고, 해당 메소드가 종료되면 Stack 에서 전부 제거된다.  원시타입 변수(byte, short, int, long, float, double, char, boolean)만 Stack에 저장된다.  원시타입을 제외한 참조 변수의 경우 Heap 영역에 생성된 Object 주소값이 저장된다.Heap 영역  Java에서 new 명령을 통해 생성된 인스턴스 변수가 놓인다.  모든 Object 타입(Integer, String, ArrayList, …)은 heap 영역에 생성된다.  Stack에 참조변수로 저장되어 Heap 영역에 Real Value가 저장되고 Stack 영역에는 주소값만 저장된다.  GC에 의해 지위지지 않는 이상 Heap 영역에 계속 남아있다.public class Main {    public static void main(String[] args) {        int port = 4000;            //원시타입 변수이므로 Stack 영역에 저장        String host = "localhost";  //인스턴스 변수이므로 Heap 영역에 실질적인 값이 저장되고 Stack에 해당 주소값이 저장    }}위와 같은 코드가 있다고 가정했을 때, 해당하는 Stack 영역과 Heap 영역은 다음과 같다.  Stack 영역에는 Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다.  만약, 여기서 host += :8080 이라는 코드를 추가하면, localhost에 값이 추가되는 것이 아니라 localhost:8080 라는 새로운 String Object가 할당되어 참조하게 된다.      즉, localhost는 unreachable 객체가 되어 GC에 의해 메모리에서 제거된다.    참고 : https://yaboong.github.io/java/2018/05/26/java-memory-management/]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Stack Area </tag>
        
          <tag> Heap Area </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OOP(객체지향 프로그래밍) 특징과 꼬리질문]]></title>
      <url>/java/2019/05/18/OOP(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8/</url>
      <content type="text"><![CDATA[OOP(객체지향 프로그래밍)  프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법  장점          코드 재사용이 용이하다.      유지보수가 쉽다.        단점          처리속도가 상대적으로 느리다.      설계시에 많은 시간과 노력이 필요하다.      클래스와 인스턴스(객체)  클래스 : 객체의 속성(Attribute)과 행위(Behavior)를 변수와 메소드로 정의한 것  객체 : 클래스에 정의된 내용을 바탕으로 실제 메모리에 할당된 데이터OOP(객체지향 프로그래밍) 4가지 특징(캡상추다)1. 캡슐화  객체의 멤버변수는 private로 설정하여 외부에서 접근을 거부하고, Getter/Setter를 public으로 선언하여 객체의 속성에 접근하도록 사용한다.  그 이유는 객체의 무결성을 보장하기 위함인데, 객체 필드에 직접적인 접근을 거부하고 잘못된 입력에 대해 Getter/Setter는 사전에 처리 및 제한할 수 있기 때문이다.&lt; 접근자 &gt;  public    : 모든 클래스, 패키지에 접근이 가능한 접근 제어자  private   : 같은 패키지에서만 접근 허용, 상속받은 자식 클래스에서는 서로 다른 패키지다 하더라도 접근 가능  default   : 같은 패키지에서만 접근 허용  protected : 같은 클래스에서만 접근 허용2. 상속  클래스의 멤버와 함수를 다른 클래스에 물려주거나, 물려 받는 것을 말하며 이를 통해 재사용성이 높아진다.3. 추상화  중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이를 하나의 클래스로 다루는 것4. 다형성  오버로딩과 오버라이딩을 통해 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력  오버로딩(Overloadding)  : 상위 클래스의 이름과 return값이 같지만, 매개변수를 다른 메소드를 만들어 가독성을 높이는 방법  오버라이딩(Overriding)   : 상위 클래스에 존재하는 메소드를 하위 클래스에서 용도에 맞게 재정의 하여 재사용성을 높이는 방법&lt; Abstract Class와 Interface &gt;  추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스다.  인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없기 때문에 상속을 통해 자식 클래스에서만 객체를 생성할 수 있다.Abstract Class(추상 클래스)  공통점을 찾아 추상화시켜서 사용하는 것으로, extends 키워드를 통해 추상 클래스를 상속받는다.  추상클래스는 추상메서드(abstract method)가 하나라도 존재하는 클래스를 말한다.  일부는 구현된 메소드도 있을 수 있고, 일부는 abstract method로 구현이 되어있지 않은 메소드도 있을 수 있다.  즉, 구현된 메소드가 있을 수 있기 때문에 만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용한다.Interface  구현 객체가 같은 동작을 한다는 것을 보장하기 위한 목적으로, implements 키워드를 통해 인터페이스를 상속받는다.  인터페이스는 쉽게 말하면 껍데기라고 말할 수 있고, 설계도 또는 명세라고 생각하면 된다.  모든 메소드가 추상 메소드이기 때문에 인터페이스를 상속받는 자식 클래스는 인터페이스의 모든 메소드를 필수적으로 구현해야 한다.&lt; static 함수 &gt;  메모리에 호출되는데 static 으로 함수 또는 클래스를 선언했을 경우에 컴파일 동시에 메모리에 호출된다.  이렇게 호출된 static은 프로그램이 종료되는 시점까지 유지된다.  Main 함수의 경우 Java에서의 프로그램의 시작과 끝이기 때문에 Static으로 선언되어야 한다.  참고) Singletone 패턴&lt; public static void main의 의미 &gt;  모든 클래스들이 접근 가능하여야 하고, 시작되기 전 메모리에 올려져 있어야 하며, return 값에는 의미가 없기 때문에 public static void main를 사용한다.Call by Value vs Call by ReferenceCall by Value (값에 의한 호출)        « Java  함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.  함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.  복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.  따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.Call by Reference (참조에 의한 호출)  함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.  함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가리킨다.)  따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.  cf) Java는 자료형은(Integer, Long, String, …) Call by Value이다. 하지만 배열, 클래스는 Call by Reference로 생각하는 것이 편하다.&lt; StringBuffer vs StringBuilder &gt;  StringBuffer    : Multi-Thread 환경에서 동기화가 가능하기 때문에 Thread-Safe하다.  StringBuilder   : 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않지만 Single-Thread 환경에서 빠르다.&lt; Annotation &gt;  어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다.  컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공 및 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공한다.  어노테이션은 컴파일러에게 이 소스코드를 어떻게 처리해야 되는 것인지 표시를 해준다.  예를들어 내장 어노테이션인 @Override 경우 해당 메소드가 부모클래스를 오버라이딩 한 메소드라고 컴파일러에게 미리 일러주는 것이다.  따라서 컴파일러는 런타임 이전에 이 메소드가 문제없이 오버라이딩 되었는지 검사한다.&lt; Generic &gt;  제네릭 타입을 이용해서 컴파일 과정에서 타입 체크를 할 수 있다.  제네릭은 클래스와 인터페이스, 메소드를 정의할 때 타입 파라미터로 사용한다.          컴파일할 때 타입을 체크해서 에러를 사전에 잡을 수 있다.      컴파일러가 타입캐스팅을 해주기 때문에 개발자가 편리하다.      타입만 다르고 코드의 내용이 대부분 일치할 때, 코드의 재사용성이 좋아진다.      ]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Java 특징 </tag>
        
          <tag> 접근자 </tag>
        
          <tag> static </tag>
        
          <tag> OOP </tag>
        
          <tag> 객체지향 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Database Sharding(샤딩)이란?]]></title>
      <url>/database/2019/05/17/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%83%A4%EB%94%A9/</url>
      <content type="text"><![CDATA[&lt; Sharding(샤딩) &gt;  샤딩은 수평 분할(Horizontal Partitioning)과 동일하며, 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.  수평 분할(Horizontal Partitioning)이란 스키마(schema)가 같은 데이터를 두 개 이상의 테이블에 나누어 저장하는 디자인을 말한다.  가령 같은 주민 데이터를 처리하기 위해 스키마가 같은 ‘서현동주민 테이블’과 ‘정자동주민 테이블’을 사용하는 것을 말한다.  데이터베이스를 샤딩하게 되면 기존에 하나로 구성될 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지를 샤드키를 기준으로 분리한다.&lt; Sharding(샤딩)의 단점 &gt;  프로그래밍적, 운영적인 복잡도가 높아진다.  즉, 샤딩을 시작하기 전에 샤딩을 피하거나 지연시킬 수 있는 방법을 찾는게 우선이다.  좀더 고스펙의 컴퓨터를 사용한다.  Read(Select) 명령이 많다면 Cache나 Database Replication을 적용한다.  Table의 일부 Column만 사용한다면 수직 분할(Vertically Partitioning)을 사용한다 / Cold &amp; Hot data를 사용한다.참고) Database Replication이란?  2개 이상의 DBMS를 Master와 Slave로 나누어 동일한 데이터를 저장한다.  Master DB는 Insert, Update, Delete의 기능을 수행하고, Slave DB에 실제 데이터를 복사한다.  Slave DB 시간이 오래걸리는 Select문의 기능을 수행하여 전체적인 Select문 성능을 향상시킨다.참고) Cold / Hot Data 란?    Naver D2 :: Cold Storage 소개  Hot data : 자주 사용되는 데이터  Cold data : 드물게 사용되거나 아예 사용되지 않는 데이터  Cold Storage : 에너지 절감을 위해 연산 능력에서 손해를 보더라도 낮은 가격과 저전력으로 자주 사용되지 않는 데이터를 처리하는 데이터 저장 장치 및 시스템&lt; Sharding(샤딩)의 주요 관점 &gt;  분산된 DB에서 어떻게 Data를 읽어올 것인지?  분산된 DB에 Data를 어떻게 잘 분산시킬지? » Shard Key를 어떻게 정의하는지에 따라 달라진다.&lt; Case 1. Algorithm Sharding &gt;  Database id를 단순하게 나누어 샤딩하는 방식  Sharding Key는 hash(key) % NUM_DB 같은 방식  장점 : 같은 값을 가지는 key-value 데이터베이스에 적합하다.  단점 : Cluster를 포함하는 Node 갯수가 변하게 되면 Resharding이 필요하다. / Hash Key로 분산되기 때문에 공간에 대한 효율이 부족하다.&lt; Case 2. Dynamic Sharding &gt;  클라이언트는 Locator Service에 접근하여 Shard Key를 얻는다.  장점 : Cluster가 포함하는 Node 갯수가 변하면 Shard Key를 추가하기만 하면 되기 때문에 확장에 유연하게 대처가능하다.  단점 : Data Relocation시에는 Locator Service의 Shard key Table도 일치시켜야 한다. / Locator에 의존할 수 밖에 없는 구조이다.&lt; Case 3. Entity Group &gt;  RDBMS의 Join, Index, Transaction을 사용하여 복잡도를 줄이는 방식과 유사  동일한 파티션의 관련 엔티티를 저장하여 단일 파티션 안에서 추가 기능을 제공하는 방식  장점 : 하나의 물리적인 Shard에 쿼리를 진행하면 효율적이된다. / 사용자의 증가에 따른 확장성이 좋은 파티셔닝이다.  단점 : 특정 파티션간 쿼리가 자주 요구되는 경우가 있다.&lt; 참고 자료 &gt;  Database의 샤딩(Sharding)이란?  How Sharding Works]]></content>
      <categories>
        
          <category> Database </category>
        
      </categories>
      <tags>
        
          <tag> Database </tag>
        
          <tag> Sharding </tag>
        
          <tag> 샤딩 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Oracle ANSI SQL과 INNER/OUTER JOIN 차이]]></title>
      <url>/database/2019/05/17/Oracle-ANSI-SQL%EA%B3%BC-%EB%82%B4%EC%99%B8%EB%B6%80-JOIN/</url>
      <content type="text"><![CDATA[&lt; ANSI SQL &gt;ANSI SQL에 대해 알아보자.  표준 SQL문이기 때문에 DBMS의 종류에 제약을 받지 않는다. (MySQL, OracleDB..)  테이블간의 Join 관계가 FROM 에서 명시되기 때문에 WHERE 문에서 조건만 확인하면 된다.  즉, 가독성이 일반 Query문보다 좋다.  대표적인 예시로 ANSI SQL의 두번째 장점인 가독성에 대해서알아보자.  일반 SQL Query는 다음과 같다.-- 일반적인 SQL QuerySELECT * FROM table1 as t1, table2 as t2 WHERE t1.a = t2.b  즉, WHERE문에서 Table을 JOIN하는 방식이다.  단순한 Query라면 가독성에 전혀 문제가 없지만, Query가 길어지게되면 가독성이 떨어질 수 밖에 없다.  이와 다르게 ANSI SQL Query 는 FROM 절에서 JOIN을 이용하여 묶고, WHERE에는 검색 조건만 넣어 가독성이 좋다.-- ANSI SQL Query SELECT * FROM table1 as t1 LEFT OUTER JOIN table as t2 ON t1.a = t2.b  위의 ANSI SQL에서는 LEFT OUTER JOIN을 사용하여 FROM절에 Table JOIN 하였다.  ANSI SQL에서 사용하는 INNER/OUERT JOIN 의 개념을 명확히 아는 것 또한 중요하다.&lt; INNER JOIN &gt;  두 테이블간 ON 조건을 만족하는 ROW만 출력된다.-- INNER JOIN SELECT * FROM table1 as t1 INNER JOIN table2 as t2 ON t1.a = t2.b;Query가 위와 같을 때, ON 조건인 t1.a = t2.b 를 만족하는 Row 만 출력된다.&lt; OUTER JOIN &gt;  대표적으로 자주 사용하는 LEFT OUTER JOIN 에 대해서 알아보자.  OUTER 명령어는 생략이 가능하다. 즉, LEFT OUTER JOIN = LEFT JOIN과 같다.  LEFT TABLE 을 기준으로 오른쪽에 덧붙이는 느낌으로 생각하면 된다.  LEFT TABLE의 결과값을 가져오고 ON 조건에 해당하는 경우 오른쪽에 매칭, 데이터가 없는 경우 NULL로 출력된다.-- OUTER JOIN SELECT * FROM table1 as t1 LEFT OUTER JOIN table2 as t2 ON t1.a = t2.b;  t1.a = t2.b 인 경우, t1의 값이 10행 이라면, 해당 쿼리의 결과도 10행이 유지되고, ON 조건에 해당하는 Row가 있다면 오른쪽에 데이터가 매칭된다.  단, 1개의 t1 행에 ON 조건을 만족하는 t2의 값이 여러개라면, Row가 증가할 수도 있다.&lt; 결론 &gt;  ANSI SQL 에 맞춰서 Query를 짜는 습관을 가지자.  WHERE 문에서는 검색조건만 넣도록, Table JOIN 은 FROM절에 묶어서 처리하자.]]></content>
      <categories>
        
          <category> Database </category>
        
      </categories>
      <tags>
        
          <tag> Database </tag>
        
          <tag> ANSI SQL </tag>
        
          <tag> INNER JOIN </tag>
        
          <tag> OUTER JOIN </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/11399 ATM]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/16/%EB%B0%B1%EC%A4%80-11399-ATM/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: ATM 문제는 오름차순 정렬 후 값을 더해가면 된다.  오름차순이 필요한 이유는 대기시간이 짧은 사람부터 해결하는 것이 뒤에 사람들이 기다리는 시간이 최소가 되기 때문이다.  Java의 경우 Arrays.sort로 정렬해도 되지만, MergeSort 구현 연습도 할 겸해서 합병정렬로 정렬했다.  입력받은 배열을 Arrays.sort 또는 MergeSort로 오름차순 정렬한다.  각 idx 마다 기다리는 시간을 더해주면서 값을 구한다.&lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static int[] sort;    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        int n = Integer.parseInt(br.readLine());        int[] arr = new int[n];        sort = new int[n];        stk = new StringTokenizer(br.readLine());        for (int i = 0; i &lt; n; i++) {            arr[i] = Integer.parseInt(stk.nextToken());        }        merge(arr, 0, n - 1);   //1. 정렬        int ans = 0, sum = 0;   //2. 각 idx 마다 기다리는 시간을 더해준다.        for (int i = 0; i &lt; n; i++) {            sum += arr[i];            ans += sum;        }        System.out.println(ans);    }    public static void merge(int[] arr, int start, int end) {        if (start &lt; end) {            int mid = (start + end) / 2;            merge(arr, start, mid);            merge(arr, mid + 1, end);            mergeSort(arr, start, mid, end);        }    }    public static void mergeSort(int[] arr, int start, int mid, int end) {        int left = start;        int right = mid + 1;        int idx = start;        while (left &lt;= mid &amp;&amp; right &lt;= end) {            if (arr[left] &lt; arr[right]) {                sort[idx++] = arr[left++];            } else {                sort[idx++] = arr[right++];            }        }        while (left &lt;= mid) sort[idx++] = arr[left++];        while (right &lt;= end) sort[idx++] = arr[right++];        for (int i = start; i &lt;= end; i++) {            arr[i] = sort[i];        }    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 11399 </tag>
        
          <tag> 백준 ATM </tag>
        
          <tag> 합병정렬 </tag>
        
          <tag> MergeSort </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/9935 문자열 폭발]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/16/%EB%B0%B1%EC%A4%80-9935-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AD%EB%B0%9C/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 문자열 폭발 문제는 스택을 활용하는 문제다.  Stack 클래스를 사용할 필요 없이 배열을 스택처럼 사용하면 된다.  입력받는 문자열을 전부 char 배열로 변환해 체크했다.  입력받는 문자열 : target  찾아야 하는 문자열 : find  옮기는 char 배열 : stack  현재 stack 배열 idx가 find 길이보다 작다면 stack 배열에 target[idx] 문자를 추가한다.  1번에 해당되지 않고 find 마지막 문자와 다르면 stack 배열에 target[idx] 문자를 추가한다.  1,2번에 해당하지 않고 find 마지막 문자와 target[idx]의 문자가 같으면 find 배열 길이만큼 for문을 돌면서 일치 여부를 확인한다.          만약 일치한다면 idx를 현재 위치로 옮긴다.(덮어 씌우니까 따로 지울 필요는 없다)      만약 일치하지 않는다면 stack 배열에 target[idx] 문자를 추가한다.      &lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        char[] target = br.readLine().toCharArray();        char[] find = br.readLine().toCharArray();        char[] stack = new char[target.length];        int idx = 0;        for (int i = 0; i &lt; target.length; i++) {            stack[idx++] = target[i];            if (idx &lt; find.length) continue;            //찾아야 하는 문자열 길이보다 작으면 계속 옮긴다            if (target[i] == find[find.length - 1]) {   //찾아야 하는 문자열 끝과 옮긴 문자가 같다면                boolean flag = false;                for (int j = 0; j &lt;= find.length - 1; j++) {        //일치여부 확인                    if (stack[idx - find.length + j] != find[j]) flag = true;                }                if (!flag) {        //일치하면 idx 앞으로 이동                    idx = idx - find.length;                }            }        }        if (idx == 0) System.out.println("FRULA");        else {            for (int i = 0; i &lt; idx; i++) {                sb.append(stack[i]);            }            System.out.println(sb);        }    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 9935 </tag>
        
          <tag> 백준 문자열 폭발 </tag>
        
          <tag> 스텍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[2019 CJ올리브네트웍스 1차 면접 후기]]></title>
      <url>/%EB%A9%B4%EC%A0%91/2019/05/14/2019-CJ%EC%98%AC%EB%A6%AC%EB%B8%8C%EB%84%A4%ED%8A%B8%EC%9B%8D%EC%8A%A4-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0/</url>
      <content type="text"><![CDATA[&lt; CJ 1차 면접 후기 &gt;CJ 면접은 특이하게 호텔 한층을 빌려서 방을 면접장처럼 개조해서 진행한다.8시 도착해서 출석체크에 서명하는데 어떤 면접을 먼저 보는지 나와있다.CJ 관련 복지 이야기 듣고 면접 대기실 이동&lt; 보고합시다 &gt;면접관 2명, 지원자 4~6명 이서 진행하는 방식이다.휴식시간 없이 거의 2시간 30분정도 계속 진행되기 때문에 화장실은 미리 다녀와야한다.인적성부터 변화가 있길래 심층 면접도 어느정도 변화가 있을 줄 알았지만 소문대로 똑같았다.주제 : 디지털 트랜스포메이션 시대에 IT 소외계층(어르신, 장애인)이 디지털 소외감을 해결하는 방안정말 주제잘못생각해서 뭐 온라인으로 TV 활용한다, 오프라인 교육한다 이런식으로 적었다가 잘못된걸 깨달았다.중간 보고 이후에 팀원 각자에게 개인 질문을 하신다.이후 다시 팀원과 회의해서 최종 발표를 하고 끝날 때 각자에게 개인 질문 + 설문 조사(자신의 역할과 팀원중 잘한사람 2명과 이유)팀원중에 시간이 부족한데 말을 계속 이어가시는 분도 있어서 힘들었던 부분도 있었던 만큼 팀원운도 어느정도 중요하다.&lt; 직무 면접 &gt;보고합시다 이후 약 한 시간정도의 공백이 있었다.운이 좋은(?) 분은 보고합시다 면접 끝나자마자 바로 직무면접 가시는 분도 계셨다.면접관 2명, 지원자 2명보통 3명씩 진행하는 반면, 토론 면접때 같이 했던 사람과 같이 면접에 들어갔다.면접관들도 최대한 편하게 해주시려고 하시고, 이야기도 되도록 들어주시려고 하신다.옆 지원자분이 말이 엄청 길었는데 다 들어주시는 모습 보면서 대단하다고 생각..자소서 기반으로 면접이 진행된다.  1분자기소개  어디서 인턴 했는지와 무슨 일을 했는지  4차 산업혁명중 최근에 공부하는게 있는지?          최근 공부하는 4차 산업혁명 기술은 없어서 난항..      AWS EC2를 최근 했다고 말씀드렸더니 그거 없어졌는데 하셔서 당황..        직무를 위해서 최근 하는 노력은?          개인 공부를 하고 있다고 말씀드림        이력서에 프로젝트가 적은데 그 이유는?          이력서에 다 적지는 않았지만 그동안 했던 프로젝트를 말씀드림        자소서에 ENM 계열사를 작성한 이유는?  ENM 계열사가 아니면 안되는지?  (농담식으로) 개발이 재미있어요?          어떻게 답변해야할지 몰라서 재미있다고 단답으로 마무리했는데 음..        자소서에 팀원간 어려움이 있었다는데 어떤 어려움인지?          R&amp;R로 해결        회사에 물어보고 싶은 것  마지막 자기 자랑이나 하고싶은 말2명이서 30분정도 걸렸는데 실질적으로 질문 받은건 몇개 안된다.면접 결과가 나와봐야 알 것 같다.]]></content>
      <categories>
        
          <category> 면접 </category>
        
      </categories>
      <tags>
        
          <tag> CJ올리브네트웍스 </tag>
        
          <tag> 면접 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[2019 CJ인적성(CJAT) 후기]]></title>
      <url>/%EC%9D%B8%EC%A0%81%EC%84%B1/2019/05/12/2019-CJ%EC%9D%B8%EC%A0%81%EC%84%B1(CJAT)-%ED%9B%84%EA%B8%B0/</url>
      <content type="text"><![CDATA[&lt; CJ 인적성(CJAT) 후기 &gt;  평소 쉽다고 소문난 CJ 인적성이지만 이번에는 예시문제 4개만 주고 아무런 정보를 주지 않았다.  기사를 찾아봐도 평소 CJ 문제집으로 공부하다가는 큰코다친다 이런식으로 나와있길래  GSAT처럼 나올 것 같은 느낌이라 20대인적성 문제를 풀면서 대비했다.&lt; CJAT 시험 정보 &gt;  GSAT처럼 단계별 풀고 넘어가는 방식  1 교시 25문제 30분 (독해, 요약 15문제 + 언어 추리 15문제)  2교시 15문제 15분 (글의 구조 순서 15문제)  3교시 25문제 35분 (수리 25문제)  4교시 15문제 20분 (신유형 도형돌리기 15문제)  다른건 둘째치고 4교시가 LG 도형돌리기와 비슷하지만 차이점이 있다.  신유형의 경우 예시문제에 규칙이 주어진다. ex) ㅇ3 =&gt; 시계방항 270도 회전, ㅁ3 =&gt; 도형 내부 270도 회전 ..  이런식으로 순서도에 따라 이동하면서 회전을 다 수행했을 때 결과를 찾으면 된다.  곧 유형 분석법이 나오겠지만 개인적으로 쉽게 푸는 방법은 보기에 전부 들어가 있는 도형 하나를 잡고 이걸 조건에 따라 같이 돌려보면 훨씬 수월하게 문제를 풀 수 있다.  총 못푼문제는 20문제 가량 되는거 같은데 결과는 나와봐야 알 것 같다.&lt; 결과 &gt;]]></content>
      <categories>
        
          <category> 인적성 </category>
        
      </categories>
      <tags>
        
          <tag> CJ올리브네트웍스 </tag>
        
          <tag> 인적성 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JVM 작동 방식]]></title>
      <url>/java/2019/05/11/JVM-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D/</url>
      <content type="text"><![CDATA[&lt; JVM(Java Virtual Machine) &gt;  JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것  또한, Java와 OS 간의 중개자 역할을 수행하여 OS에 구애받지 않고 재사용을 가능하게 한다.  메모리관리 및 Garbage Collection 역할을 수행하며 Stack 기반의 가상머신이다.&lt; Java 프로그램 실행 과정 &gt;  프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.  자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.  Class Loader를 통해 class파일들을 JVM으로 로딩한다.  로딩된 class파일들은 Execution engine을 통해 해석된다.  해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다.Class Loader(클래스 로더)  클래스 로더는 .class 파일을 읽어 바이트 코드를 메소드 영역(Method Area)에 저장한다.  Runtime 시에 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할을 수행한다.&lt; Runtime Data Area &gt;  프로그램 수행을 위해 os로부터 할당받는 메모리 영역으로 5가지로 볼 수 있다.Method area  클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리공간이다.  클래스 이름, 부모 클래스 이름, 메소드, 변수 정보 등과 같은 수준의 모든 클래스 정보와 static 변수들을 저장한다.Heap area  모든 객체를 저장하는 가상 메모리 공간이다. new 연산자로 생성된 객체와 배열을 저장한다.Stack area  프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.  각종 형태의 변수나 임시 데이터, 스레드, 메소드 정보를 저장한다.PC Registers  Thread가 어떤 부분을 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 가진다.Native Method Stacks  자바 프로그램이 컴파일되어 생성되는 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.&lt; Execution Engine(실행 엔진) &gt;  바이트 코드로 된 .class 파일을 실행한다. 바이트 코드를 한줄씩 읽고 다양한 메모리 영역에 나타난 데이터와 정보를 사용한다.Interpreter  실행 엔진은 바이트코드를 한줄씩 읽어서 실행한다. 단점은 여러번 하나의 메소드를 호출할 경우 매번 해석을 요청해야하기 때문에 비효율적이다.JIT(Just-In-Time)  인터프리터 방식의 단점을 보완하기 위해 도입된 JIT 컴파일러이다.  전체 바이트 코드를 컴파일하고 네이티브 코드로 변경하여 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다.  JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메서드가 자주 수행되는지 체크하고, 일정 정도를 넘을 때 네이티브 코드로 변경한다.&lt; Garbage Collector &gt;  메모리 관리를 위한 방법 중의 하나로, Heap 영역 안의 Garbage를 찾아내서 Heap의 메모리를 회수한다.  참조되고 있지 않은 객체를 Garbage라고 하며, Garbage를 판별하기 위해 Reachability 개념을 사용한다.  한 객체가 다른 객체를 참조하며 다른 객체는 또다른 객체를 참조할 경우에는 유효한 최초의 참조가 무엇인지 파악해야 되는데, 이를 객체 참조의 root set이라고 한다.  힙 내의 다른 객체에 의한 참조  Java 스택, 즉 Java 메서드 실행 시에 사용하는 지역 변수와 파라미터들에 의한 참조  네이티브 스택, 즉 JNI(Java Native Interface)에 의해 생성된 객체에 대한 참조  메서드 영역의 정적 변수에 의한 참조  2, 3, 4번의 참조의 경우 root set이 되어 reachability를 판가름하는 기준이 된다.  즉 root set으로부터 시작한 객체들은 reachable이며, root set과 무관한 객체들이 unreachable 객체로 GC의 대상이 된다.메모리 누수 현상  컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상이다.  메모리 동적 할당시 Heap 영역에 할당되는데, 사용자가 해제하지 않는 경우 Heap 영역 메모리 공간을 계속 차지하게 된다.  이는 메모리 부족으로 시스템이 다운될 수도 있는 위험이 있다.  Java에서 Garbage Collector가 없다면 메모리 누수의 위험이 높다.&lt; 참조 &gt;  http://asfirstalways.tistory.com/158  http://mygumi.tistory.com/115?category=648758  https://github.com/DaeHeeKim93/DaeHeeKim-Review/tree/master/Java/GC]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> JAVA </tag>
        
          <tag> JVM </tag>
        
          <tag> GC </tag>
        
          <tag> Garbage Collector </tag>
        
          <tag> Heap </tag>
        
          <tag> Stack </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[백준/1104 리모콘]]></title>
      <url>/%EB%B0%B1%EC%A4%80/algorithm/2019/05/11/%EB%B0%B1%EC%A4%80-1104-%EB%A6%AC%EB%AA%A8%EC%BD%98/</url>
      <content type="text"><![CDATA[&lt; 문제 분석 및 풀이 방법 &gt;Backjoon :: 리모콘 문제는 브루트 포스를 활용하는 문제다.  모든 경우의 수를 다 해보고 최소값을 찾으면 된다.  2가지로 나눠서 생각하면 쉽게 접근할 수 있다.  초기값 100에서 +, - 만을 활용해 이동할 때 필요한 cnt  새로운 값을 입력받아서 해당 값에서부터 +, -로 이동할 때 필요한 cnt  특히 2번의 경우에는 새로운 값이 1자리 숫자 ~ 6자리 숫자까지 가능하는 점을 인지해야 한다.&lt; 소스 코드 &gt;import java.io.*;import java.util.*;public class Main {    public static StringTokenizer stk;    public static StringBuilder sb = new StringBuilder();    public static boolean[] button = new boolean[12];    public static int ans = Integer.MAX_VALUE;    public static int n;    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        n = Integer.parseInt(br.readLine());        int m = Integer.parseInt(br.readLine());        if (m != 0) stk = new StringTokenizer(br.readLine());        for (int i = 0; i &lt; m; i++) {            String s = stk.nextToken();            if (s.equals("+")) s = "10";            if (s.equals("-")) s = "11";            button[Integer.parseInt(s)] = true;        }        //초기값 100에서 갈 수 있는 최단경로값 계산        if (!button[10] &amp;&amp; (100 - n) &gt;= 0) ans = Math.min(ans, 100 - n);        if (!button[11] &amp;&amp; (n - 100) &gt;= 0) ans = Math.min(ans, n - 100);        //0~9까지 모든 경우의 수 탐색        for (int i = 0; i &lt; 10; i++) {            if (!button[i]) dfs(i, 1, 1);        }        System.out.println(ans);    }    public static int dfs(int num, int len, int cnt) {        if (len &gt; ans) return Integer.MAX_VALUE;    //현재 답보다 커지면 가지치기        if (cnt == 6) {     //6개의 숫자를 골랏을 때            return ans = Math.min(ans, getRes(num, len));        }        for (int i = 0; i &lt; 10; i++) {            if (i == 0) {   //6자리가 아닌 수                dfs(num, len, cnt + 1);            }            if (!button[i]) {   //6자리를 만드는 경우                dfs(num * 10 + i, len + 1, cnt + 1);            }        }        return Integer.MAX_VALUE;    }    public static int getRes(int num, int cnt) {        if (n == num) return cnt;        if (!button[10] &amp;&amp; n &gt; num) return cnt + n - num;        if (!button[11] &amp;&amp; n &lt; num) return cnt + num - n;        return Integer.MAX_VALUE;    }}]]></content>
      <categories>
        
          <category> 백준 </category>
        
          <category> Algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 백준 </tag>
        
          <tag> 백준 1104 </tag>
        
          <tag> 백준 리모콘 </tag>
        
          <tag> 브루트 포스 </tag>
        
          <tag> DFS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[11번가 SKCT 및 코딩테스트 후기]]></title>
      <url>/%EC%9D%B8%EC%A0%81%EC%84%B1/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/2019/05/11/11%EB%B2%88%EA%B0%80-SKCT-%EB%B0%8F-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0/</url>
      <content type="text"><![CDATA[&lt; 11번가 인턴 SKCT 및 코딩테스트 후기 &gt;다른 서류는 잘안붙는데 체험형 인턴이라 그런가 붙었다.제출란에 포트폴리오가 선택이였는데 몇개 추가해서 제출한 덕인거같은 느낌..?&lt; SKCT 후기 &gt;처음 보는 SKCT였다.듣기로는 2019 상반기 공채랑 문제가 똑같다고 하던데 본인은 처음이라 잘 모르겠다.총 인원 : 71명응시 : 40명불참 : 31명개발 직군만 불참이 거의 절반가까이 된다.아마도 체험형이고, 다른 기업 시험이 있기 때문에 겹쳐서 대부분 포기한 것이라 생각한다.교재는 위포트를 사용했는데, 실제 시험장에서는 위포트보다 쉬웠다.실행 역량유튜브 보면서 공부(히로와 면접술사)했다.SKCT 실행역량에서 중요한 점은  역할에 맞게 행동한다.  주도적으로 당사자와 되도록 해결한다.  업무상 문제라면 보고해서 조치를 받는다.위 방식대로 풀면 어느정도 감이 잡힌다.실행역량은 겨우 다풀었는데 뒤에 인적성은 10문제 넘게 못푼것 같다.결과가 나와봐야 알 것 같다.&lt; 코딩 테스트 &gt;진행 방식 : 3문제 / 2시간코딩테스트 보는 기업중 복붙을 못하게하는 기업이 있는데, 정말 이해할수가 없다.자바같은경우 오버라이드하면 다적어야하는데..어느 줄에서 오류가 발생한지 알아내는 디버깅마저 힘들었다.1번 문제는 단순 구현문제였는데 별로 어렵지 않았다.2번 문제는 괄호의 값 문제와 유사하다.입력으로 압축된 문자를 주어주고 이를 풀어내는 문제였다. ex) 4(3(h)g) =&gt; hhghhghhghhg여기서 계속 인덱스오류가 나서 못찾고 결국 제출했다.다시 생각해보니 Stack으로 풀면되는 문제였는데.. 아쉬움이 남는다.3번 문제도 네트워크 연결 문제와 상당히 비슷했다.시험 당시에는 Union-Find가 아닌 Dijkstra로 풀었는데, 어디서 꼬였는지 절반만 맞고, 시간초과가 난 상태로 제출했다.한마디로 절반만 맞은셈이니까 틀린문제다.여러 유형을 더 접해봐야 할것 같다.2번문제를 Stack으로 해결한다고 좀더 빨리 생각해야했는데 하는 아쉬움이 남는다.&lt; 결과 &gt;]]></content>
      <categories>
        
          <category> 인적성 </category>
        
          <category> 코딩테스트 </category>
        
      </categories>
      <tags>
        
          <tag> 11번가 </tag>
        
          <tag> 코딩테스트 </tag>
        
          <tag> 인적성 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tistory to Github]]></title>
      <url>/guide/2013/12/25/Tistory-to-Github/</url>
      <content type="text"><![CDATA[기존 Tistory https://sophia2730.tistory.com/ 에서 Github 이전 작업 중입니다.Normal blockalert('Hello World!');print 'helloworld'Highlight blockalert( 'Hello, world!' );print 'helloworld'def foo  puts 'foo'enddef foo  puts 'foo'end123def foo  puts 'foo'end#include &lt;iostream&gt;using namespace std;void foo(int arg1, int arg2){}int main(){  string str;  foo(1, 2);  cout &lt;&lt; "Hello World" &lt;&lt; endl;  return 0;}Image TestLocalcd /Users/sophia/Desktop/Github/cs-Devlogbundle exec jekyll server]]></content>
      <categories>
        
          <category> Guide </category>
        
      </categories>
      <tags>
        
          <tag> Test </tag>
        
          <tag> Guide </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
