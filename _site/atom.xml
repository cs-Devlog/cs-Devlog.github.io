<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-22T00:21:30+09:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Devlog</title><author><name>ChanSu Kim</name></author><entry><title type="html">TCP/UDP란?</title><link href="http://localhost:4000/network/2019/05/22/TCP%EC%99%80-UDP/" rel="alternate" type="text/html" title="TCP/UDP란?" /><published>2019-05-22T00:01:00+09:00</published><updated>2019-05-22T00:01:00+09:00</updated><id>http://localhost:4000/network/2019/05/22/TCP%EC%99%80%20UDP</id><content type="html" xml:base="http://localhost:4000/network/2019/05/22/TCP%EC%99%80-UDP/">&lt;h1 id=&quot;tcptransmission-control-protocol&quot;&gt;TCP((Transmission Control Protocol)&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/tcp.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 상에서 데이터를 패킷 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다.&lt;/li&gt;
  &lt;li&gt;TCP와 IP를 함께 사용하는데, TCP는 발신지에서 수신지로 패킷을 전송하기 위한 논리적 경로를 배정한다.&lt;/li&gt;
  &lt;li&gt;연결형 서비스로 가상 회선 방식을 제공한다.
    &lt;ul&gt;
      &lt;li&gt;연결 시 3-way Handshaking 사용, 해체 시 4-way Handshaking 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;흐름제어(송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.)&lt;/li&gt;
  &lt;li&gt;혼잡제어(네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것)&lt;/li&gt;
  &lt;li&gt;높은 신뢰성을 보장하지만 UDP보다 느린 속도를 가진다. ( 신뢰성 &amp;gt; 속도 )&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;udpuser-datagram-protocol&quot;&gt;UDP(User Datagram Protocol)&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/udp.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 데이터그램 단위로 처리하는 프로토콜, 데이터그램이란 독립적인 관계를 지니는 패킷&lt;/li&gt;
  &lt;li&gt;비연결형 프로토콜로 연결을 위한 논리적인 경로가 없다. 즉, 각각 다른 경로로 패킷을 전송하여 빠른 속도를 보여준다.&lt;/li&gt;
  &lt;li&gt;UDP Header의 CheckSum 필드를 통해 최소한의 오류만 검출한다.&lt;/li&gt;
  &lt;li&gt;흐름제어를 못하기 때문에 패킷이 재대로 전송 되었는지, 오류가 없는지 확인할 수 없다.&lt;/li&gt;
  &lt;li&gt;빠른 속도를 보여주지만 신뢰성이 없다. 스트리밍같은 서비스에 주로 사용된다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>ChanSu Kim</name></author><category term="Network" /><category term="TCP" /><category term="가상회선 패킷" /><category term="UDP" /><category term="데이터그램 패킷" /><summary type="html">TCP((Transmission Control Protocol) 인터넷 상에서 데이터를 패킷 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. TCP와 IP를 함께 사용하는데, TCP는 발신지에서 수신지로 패킷을 전송하기 위한 논리적 경로를 배정한다. 연결형 서비스로 가상 회선 방식을 제공한다. 연결 시 3-way Handshaking 사용, 해체 시 4-way Handshaking 사용 흐름제어(송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.) 혼잡제어(네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것) 높은 신뢰성을 보장하지만 UDP보다 느린 속도를 가진다. ( 신뢰성 &amp;gt; 속도 ) UDP(User Datagram Protocol) 데이터를 데이터그램 단위로 처리하는 프로토콜, 데이터그램이란 독립적인 관계를 지니는 패킷 비연결형 프로토콜로 연결을 위한 논리적인 경로가 없다. 즉, 각각 다른 경로로 패킷을 전송하여 빠른 속도를 보여준다. UDP Header의 CheckSum 필드를 통해 최소한의 오류만 검출한다. 흐름제어를 못하기 때문에 패킷이 재대로 전송 되었는지, 오류가 없는지 확인할 수 없다. 빠른 속도를 보여주지만 신뢰성이 없다. 스트리밍같은 서비스에 주로 사용된다</summary></entry><entry><title type="html">OSI 7 Layer란?</title><link href="http://localhost:4000/network/2019/05/22/OSI-7-Layer/" rel="alternate" type="text/html" title="OSI 7 Layer란?" /><published>2019-05-22T00:00:30+09:00</published><updated>2019-05-22T00:00:30+09:00</updated><id>http://localhost:4000/network/2019/05/22/OSI%207%20Layer</id><content type="html" xml:base="http://localhost:4000/network/2019/05/22/OSI-7-Layer/">&lt;h1 id=&quot;osi-7-layer이란&quot;&gt;OSI 7 Layer이란?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개방형 시스템 상호연결(Open System Intercon-nection, OSI) 모델&lt;/li&gt;
  &lt;li&gt;상호 이질적인 네트워크간의 연결에 어려움이 많은데 이러한 호환성의 결여를 막기위해 ISO(국제 표준화 기구)에서는 OSI 참조모델을 제시함&lt;/li&gt;
  &lt;li&gt;네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;네트워크 통신 과정을 7단계로 나눈 이유는?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다!&lt;/li&gt;
  &lt;li&gt;문제가 발생하더라도 해당 계층만 고치면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;osi-7-layer-구조&quot;&gt;OSI 7 Layer 구조&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/osi7layer.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1단계--물리-계층physical&quot;&gt;1단계 : 물리 계층(Physical)**&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;말 그대로 시스템의 물리적 표현을 나타낸다. (=물리적 장비)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2단계--데이터-링크-계층-data-link&quot;&gt;2단계 : 데이터 링크 계층 (Data Link)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;노드 간 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다.&lt;/li&gt;
  &lt;li&gt;주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다. ex) 이더넷&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3단계--네트워크-계층network&quot;&gt;3단계 : 네트워크 계층(Network)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층&lt;/li&gt;
  &lt;li&gt;데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)&lt;/li&gt;
  &lt;li&gt;보스턴에 있는 컴퓨터가 캘리포니아에 있는 서버에 연결하려고 할 때 그 경로는 수백 만 가지다. 이 계층의 라우터가 이 작업을 효율적으로 처리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4단계--전송-계층transport&quot;&gt;4단계 : 전송 계층(Transport)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.&lt;/li&gt;
  &lt;li&gt;전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)이다. 대표적인 예로 TCP가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5단계--세션-계층session&quot;&gt;5단계 : 세션 계층(Session)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.&lt;/li&gt;
  &lt;li&gt;TCP/IP 세션을 만들고 없애는 책임을 진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6단계--표현-계층presentation&quot;&gt;6단계 : 표현 계층(Presentation)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코드 간의 번역을 담당하여 사용자의 명령어를 완성 및 결과 표현한다.&lt;/li&gt;
  &lt;li&gt;데이터를 안전하게 전송하기 위해 암호화/복호화 하는 역할 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7단계--응용-계층application&quot;&gt;7단계 : 응용 계층(Application)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.&lt;/li&gt;
  &lt;li&gt;사용자는 용도에 맞는 프로토콜을 선택하고 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. ex) MS Office, Chrome …&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;osi-7-layer-쉽게-외우는-방법&quot;&gt;OSI 7 Layer 쉽게 외우는 방법&lt;/h1&gt;
&lt;p&gt;CIOKorea에 나와있는 재미있는 방법&lt;/p&gt;

&lt;p&gt;물리 계층에서 응용 계층까지(아래에서 위로)(P-D-N-T-S-P-A)&lt;/p&gt;

&lt;p&gt;소시지 피자를 버리지 말아 주세요(Please-Do-Not-Throw-Sausage-Pizza-Away)&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeareSoft/tech-interview/&quot;&gt;https://github.com/WeareSoft/tech-interview/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://shlee0882.tistory.com/110&quot;&gt;https://shlee0882.tistory.com/110&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ciokorea.com/news/36536&quot;&gt;http://www.ciokorea.com/news/36536&lt;/a&gt;&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="Network" /><category term="OSI 7 Layer" /><summary type="html">OSI 7 Layer이란? 개방형 시스템 상호연결(Open System Intercon-nection, OSI) 모델 상호 이질적인 네트워크간의 연결에 어려움이 많은데 이러한 호환성의 결여를 막기위해 ISO(국제 표준화 기구)에서는 OSI 참조모델을 제시함 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것 네트워크 통신 과정을 7단계로 나눈 이유는? 계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다! 문제가 발생하더라도 해당 계층만 고치면 된다. OSI 7 Layer 구조 1단계 : 물리 계층(Physical)** 말 그대로 시스템의 물리적 표현을 나타낸다. (=물리적 장비) 2단계 : 데이터 링크 계층 (Data Link) 노드 간 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다. 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다. ex) 이더넷 3단계 : 네트워크 계층(Network) 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅) 보스턴에 있는 컴퓨터가 캘리포니아에 있는 서버에 연결하려고 할 때 그 경로는 수백 만 가지다. 이 계층의 라우터가 이 작업을 효율적으로 처리한다. 4단계 : 전송 계층(Transport) 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다. 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)이다. 대표적인 예로 TCP가 있다. 5단계 : 세션 계층(Session) 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다. TCP/IP 세션을 만들고 없애는 책임을 진다. 6단계 : 표현 계층(Presentation) 코드 간의 번역을 담당하여 사용자의 명령어를 완성 및 결과 표현한다. 데이터를 안전하게 전송하기 위해 암호화/복호화 하는 역할 수행 7단계 : 응용 계층(Application) HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다. 사용자는 용도에 맞는 프로토콜을 선택하고 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. ex) MS Office, Chrome … OSI 7 Layer 쉽게 외우는 방법 CIOKorea에 나와있는 재미있는 방법 물리 계층에서 응용 계층까지(아래에서 위로)(P-D-N-T-S-P-A) 소시지 피자를 버리지 말아 주세요(Please-Do-Not-Throw-Sausage-Pizza-Away) 참고 https://github.com/WeareSoft/tech-interview/ https://shlee0882.tistory.com/110 http://www.ciokorea.com/news/36536</summary></entry><entry><title type="html">HTTP와 REST API, Cookie, Session</title><link href="http://localhost:4000/network/2019/05/21/HTTP%EC%99%80-REST-API/" rel="alternate" type="text/html" title="HTTP와 REST API, Cookie, Session" /><published>2019-05-21T17:00:00+09:00</published><updated>2019-05-21T17:00:00+09:00</updated><id>http://localhost:4000/network/2019/05/21/HTTP%EC%99%80%20REST%20API</id><content type="html" xml:base="http://localhost:4000/network/2019/05/21/HTTP%EC%99%80-REST-API/">&lt;h1 id=&quot;httphypertext-transfer-protocol이란&quot;&gt;HTTP(HyperText Transfer Protocol)이란?&lt;/h1&gt;
&lt;p&gt;인터넷에서 데이터를 주고받을 수 있는 프로토콜로 웹 서버와 클라이언트간 통신하기 위한 규약&lt;/p&gt;

&lt;p&gt;어느 종류의 데이터든지 전송할 수 있도록 설계되어있다. HTML 뿐만아니라 이미지, 동영상, 오디오, 텍스트 문서 등 종류를 가리지 않는다.&lt;/p&gt;

&lt;p&gt;이름 그대로 하이퍼텍스트를 기반으로 데이터를 전송하겠다는 말이다. 간단히 말하면 링크기반으로 데이터에 접속하겠다는 의미이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http-작동-방식&quot;&gt;HTTP 작동 방식&lt;/h1&gt;
&lt;p&gt;TCP/IP를 사용하는 응용 프로토콜이며 HTTP 메세지는 HTTP 서버와 HTTP 클라이언트가 해석한다.&lt;/p&gt;

&lt;p&gt;HTTP는 연결 상태를 유지하지 않는 프로토콜이기 때문에 서버에 연결하고 Request에서 Response를 받으면 연결을 끊어버린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt; : 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt; : 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수 없다. 이를 위해 Cookie를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network_http.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;크롬 개발자도구의 네트워크 탭의 정보를 해석해보자.&lt;/p&gt;

&lt;p&gt;요청한 URL은 &lt;a href=&quot;http://sophia2730.tistory.com&quot;&gt;http://sophia2730.tistory.com&lt;/a&gt; 이며 200 코드로 성공적인 요청이였다는 결과를 받았다.&lt;/p&gt;

&lt;p&gt;여기서 작동한 Method는 GET이며 POST, PUT(수정) 등의 메소드를 사용하여 클라이언트와 서버가 데이터를 주고받는다.&lt;/p&gt;

&lt;p&gt;여기서 URI를 자원으로 보고 Method를 동사로 보는 개발 방식이 REST 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;rest-api란&quot;&gt;REST API란?&lt;/h1&gt;
&lt;p&gt;웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일로, 자원을 표현으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.&lt;/p&gt;

&lt;p&gt;즉, URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;REST API는 두 가지 특징을 가진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;URI는 정보의 자원을 표현해야 한다.  ex) GET /members/delete/1 (X),  DELETE /members/1 (O)&lt;/li&gt;
  &lt;li&gt;자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 방식으로 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cookie와-session&quot;&gt;Cookie와 Session&lt;/h1&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;모든 내용이 클라이언트측에서 저장되며 서버에 요청할 때 마다 HTTP 헤더에 쿠키 내용(&lt;strong&gt;KEY=VALUE&lt;/strong&gt;)을 전달합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web_cookie.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;최초 접속일 경우 사용자ID, 로그인시간, IP등을 암호화한 구문을 클라이언트의 쿠키에 &lt;strong&gt;KEY=VALUE&lt;/strong&gt; 된 구문으로 생성해 클라이언트에게 쿠키에 저장하라고 응답합니다. (예 : state=ASKHDNxxu7432keedsa7jhklsadasdmslk )&lt;/li&gt;
  &lt;li&gt;클라이언트는 매번 서버에 요청할 때 위 쿠키를 전달합니다.&lt;/li&gt;
  &lt;li&gt;서버는 로그인상황을 검사하기 위해서 매번 쿠키를 읽습니다. 그리고 위의 키를 찾아 정보를 해독하고, 서버에 있는 사용자 정보와 비교해 일치하면 로그인된 것으로 보고, 일치하지 않으면 불량요청 혹은 로그인하지 않은 사용자로 판별합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;session&quot;&gt;Session&lt;/h2&gt;
&lt;p&gt;Session은 서버쪽에 저장되는 쿠키이며 클라이언트가 서버에 Request를 보내면 서버는 클라이언트한테 세션 ID를 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web_session.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;로그인 요청이 들어왔을 때 정보가 일치하면 서버는 사용자ID, 로그인시간, IP 등을 저장하는 Session을 생성합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트에 응답할 때 세션을 찾을 수 있는 Session ID를 클라이언트에 전달합니다.(보통 쿠키로 전달)&lt;/li&gt;
  &lt;li&gt;클라이언트는 다음 요청시, Session ID를 함께 요청(쿠키를 사용하든 다른 방법을 사용하든)합니다.&lt;/li&gt;
  &lt;li&gt;서버가 요청을 받은 경우 Session ID를 이용해서 서버에 저장된 세션을 찾아와 로그인을 확인할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cookie와-session의-저장-정보와-위치&quot;&gt;Cookie와 Session의 저장 정보와 위치&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cookie-session.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://message0412.tistory.com/entry/HTTP-프로토콜-알아보기1&quot;&gt;https://message0412.tistory.com/entry/HTTP-프로토콜-알아보기1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hashcode.co.kr/questions/3243&quot;&gt;https://hashcode.co.kr/questions/3243&lt;/a&gt;&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="Network" /><category term="HTTP" /><category term="REST" /><category term="Cookie" /><category term="Session" /><summary type="html">HTTP(HyperText Transfer Protocol)이란? 인터넷에서 데이터를 주고받을 수 있는 프로토콜로 웹 서버와 클라이언트간 통신하기 위한 규약 어느 종류의 데이터든지 전송할 수 있도록 설계되어있다. HTML 뿐만아니라 이미지, 동영상, 오디오, 텍스트 문서 등 종류를 가리지 않는다. 이름 그대로 하이퍼텍스트를 기반으로 데이터를 전송하겠다는 말이다. 간단히 말하면 링크기반으로 데이터에 접속하겠다는 의미이다. HTTP 작동 방식 TCP/IP를 사용하는 응용 프로토콜이며 HTTP 메세지는 HTTP 서버와 HTTP 클라이언트가 해석한다. HTTP는 연결 상태를 유지하지 않는 프로토콜이기 때문에 서버에 연결하고 Request에서 Response를 받으면 연결을 끊어버린다. 장점 : 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리 할 수 있다. 단점 : 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수 없다. 이를 위해 Cookie를 사용한다. 크롬 개발자도구의 네트워크 탭의 정보를 해석해보자. 요청한 URL은 http://sophia2730.tistory.com 이며 200 코드로 성공적인 요청이였다는 결과를 받았다. 여기서 작동한 Method는 GET이며 POST, PUT(수정) 등의 메소드를 사용하여 클라이언트와 서버가 데이터를 주고받는다. 여기서 URI를 자원으로 보고 Method를 동사로 보는 개발 방식이 REST 방식이다. REST API란? 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일로, 자원을 표현으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다. 즉, URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다. REST API는 두 가지 특징을 가진다. URI는 정보의 자원을 표현해야 한다. ex) GET /members/delete/1 (X), DELETE /members/1 (O) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다. 이러한 방식으로 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다. Cookie와 Session Cookie 모든 내용이 클라이언트측에서 저장되며 서버에 요청할 때 마다 HTTP 헤더에 쿠키 내용(KEY=VALUE)을 전달합니다. 최초 접속일 경우 사용자ID, 로그인시간, IP등을 암호화한 구문을 클라이언트의 쿠키에 KEY=VALUE 된 구문으로 생성해 클라이언트에게 쿠키에 저장하라고 응답합니다. (예 : state=ASKHDNxxu7432keedsa7jhklsadasdmslk ) 클라이언트는 매번 서버에 요청할 때 위 쿠키를 전달합니다. 서버는 로그인상황을 검사하기 위해서 매번 쿠키를 읽습니다. 그리고 위의 키를 찾아 정보를 해독하고, 서버에 있는 사용자 정보와 비교해 일치하면 로그인된 것으로 보고, 일치하지 않으면 불량요청 혹은 로그인하지 않은 사용자로 판별합니다. Session Session은 서버쪽에 저장되는 쿠키이며 클라이언트가 서버에 Request를 보내면 서버는 클라이언트한테 세션 ID를 제공한다. 로그인 요청이 들어왔을 때 정보가 일치하면 서버는 사용자ID, 로그인시간, IP 등을 저장하는 Session을 생성합니다. 클라이언트에 응답할 때 세션을 찾을 수 있는 Session ID를 클라이언트에 전달합니다.(보통 쿠키로 전달) 클라이언트는 다음 요청시, Session ID를 함께 요청(쿠키를 사용하든 다른 방법을 사용하든)합니다. 서버가 요청을 받은 경우 Session ID를 이용해서 서버에 저장된 세션을 찾아와 로그인을 확인할 수 있습니다. Cookie와 Session의 저장 정보와 위치 참고 https://message0412.tistory.com/entry/HTTP-프로토콜-알아보기1 https://hashcode.co.kr/questions/3243</summary></entry><entry><title type="html">주소창에 www.naver.com을 치면 일어나는 일</title><link href="http://localhost:4000/network/2019/05/21/www.naver.com%EC%9D%84-%EC%B9%98%EB%A9%B4-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC/" rel="alternate" type="text/html" title="주소창에 www.naver.com을 치면 일어나는 일" /><published>2019-05-21T14:00:00+09:00</published><updated>2019-05-21T14:00:00+09:00</updated><id>http://localhost:4000/network/2019/05/21/www.naver.com%EC%9D%84%20%EC%B9%98%EB%A9%B4%20%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%20%EC%9D%BC</id><content type="html" xml:base="http://localhost:4000/network/2019/05/21/www.naver.com%EC%9D%84-%EC%B9%98%EB%A9%B4-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC/">&lt;h1 id=&quot;주소창에-wwwnavercom을-치면-일어나는-일&quot;&gt;주소창에 www.naver.com을 치면 일어나는 일&lt;/h1&gt;
&lt;p&gt;주소창에 www.naver.com을 입력하면 어떤 일이 일어날까?&lt;/p&gt;

&lt;p&gt;면접 질문에서도 종종 나오는 이 방식은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;방식에 대해 이해하기 전에 IP 주소, 도메인에 대한 사전 지식이 필요하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;ip-주소&quot;&gt;IP 주소&lt;/h1&gt;
&lt;p&gt;IP 주소란 많은 컴퓨터들이 인터넷 상에서 서로를 인식하기 위해 지정받은 식별용 번호라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;현재는 IPv4 버전(32비트)로 구성되어 있으며 한번씩은 들어봤을 법한 127.0.0.1 같은 주소를 말한다.&lt;/p&gt;

&lt;p&gt;시간이 갈수록 IPv4 주소의 부족으로 IPv6가 생겼는데, 128비트로 구성되어있기 때문에 IP 주소가 부족하지 않다는 특징이 있다.&lt;/p&gt;

&lt;h1 id=&quot;도메인-네임domain-name&quot;&gt;도메인 네임(Domain Name)&lt;/h1&gt;
&lt;p&gt;IP주소는 12자리의 숫자로 되어있기 때문에 사람이 외우기 힘들다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 12자리의 IP 주소를 문자로 표현한 주소를 &lt;strong&gt;&lt;em&gt;도메인 네임&lt;/em&gt;&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;다시 말해서, 도메인 네임은 ‘naver.com’처럼 몇 개의 의미있는 문자들과 점(.)의 조합으로 구성된다.&lt;/p&gt;

&lt;p&gt;도메인 네임은 사람의 편의성을 위해 만든 주소이므로 실제로는 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;이때 사용할 수 있도록 미리 도메인 네임과 함께 해당하는 IP 주소값을 한 쌍으로 저장하고 있는 데이터베이스를 &lt;strong&gt;&lt;em&gt;DNS(Domain Name System)&lt;/em&gt;&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;p&gt;다시 말해 사람이 도메인 네임으로 입력하면 DNS를 이용해 컴퓨터는 IP 주소를 찾아갈 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;web-동작-원리&quot;&gt;WEB 동작 원리&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/web_process.png&quot; alt=&quot;web_process&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 브라우저에 도메인 네임(www.naver.com)을 입력한다.&lt;/li&gt;
  &lt;li&gt;사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.&lt;/li&gt;
  &lt;li&gt;페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.&lt;/li&gt;
  &lt;li&gt;이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.&lt;/li&gt;
  &lt;li&gt;검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.&lt;/li&gt;
  &lt;li&gt;도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;어려운 개념은 아니니 재미삼아 읽어봐도 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;출처 : &lt;a href=&quot;http://tcpschool.com/webbasic/works&quot;&gt;http://tcpschool.com/webbasic/works&lt;/a&gt;&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="Network" /><category term="IP 주소" /><category term="DNS" /><category term="도메인" /><summary type="html">주소창에 www.naver.com을 치면 일어나는 일 주소창에 www.naver.com을 입력하면 어떤 일이 일어날까? 면접 질문에서도 종종 나오는 이 방식은 생각보다 간단하다. 방식에 대해 이해하기 전에 IP 주소, 도메인에 대한 사전 지식이 필요하다. IP 주소 IP 주소란 많은 컴퓨터들이 인터넷 상에서 서로를 인식하기 위해 지정받은 식별용 번호라고 생각하면 된다. 현재는 IPv4 버전(32비트)로 구성되어 있으며 한번씩은 들어봤을 법한 127.0.0.1 같은 주소를 말한다. 시간이 갈수록 IPv4 주소의 부족으로 IPv6가 생겼는데, 128비트로 구성되어있기 때문에 IP 주소가 부족하지 않다는 특징이 있다. 도메인 네임(Domain Name) IP주소는 12자리의 숫자로 되어있기 때문에 사람이 외우기 힘들다는 단점이 있다. 그렇기 때문에 12자리의 IP 주소를 문자로 표현한 주소를 도메인 네임이라고 한다. 다시 말해서, 도메인 네임은 ‘naver.com’처럼 몇 개의 의미있는 문자들과 점(.)의 조합으로 구성된다. 도메인 네임은 사람의 편의성을 위해 만든 주소이므로 실제로는 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 작업이 필요하다. 이때 사용할 수 있도록 미리 도메인 네임과 함께 해당하는 IP 주소값을 한 쌍으로 저장하고 있는 데이터베이스를 DNS(Domain Name System) 이라고 부른다. 다시 말해 사람이 도메인 네임으로 입력하면 DNS를 이용해 컴퓨터는 IP 주소를 찾아갈 수 있다. WEB 동작 원리 사용자가 브라우저에 도메인 네임(www.naver.com)을 입력한다. 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다. 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다. 어려운 개념은 아니니 재미삼아 읽어봐도 좋을 것 같다. 출처 : http://tcpschool.com/webbasic/works</summary></entry><entry><title type="html">ArrayList와 LinkedList</title><link href="http://localhost:4000/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2019/05/21/ArrayList%EC%99%80-LinkedList/" rel="alternate" type="text/html" title="ArrayList와 LinkedList" /><published>2019-05-21T14:00:00+09:00</published><updated>2019-05-21T14:00:00+09:00</updated><id>http://localhost:4000/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2019/05/21/ArrayList%EC%99%80%20LinkedList</id><content type="html" xml:base="http://localhost:4000/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2019/05/21/ArrayList%EC%99%80-LinkedList/">&lt;h1 id=&quot;arraylist와-linkedlist&quot;&gt;ArrayList와 LinkedList&lt;/h1&gt;
&lt;p&gt;ArrayList와 LinktedList 둘다 모두 Java에서 제공하는 List 인터페이스를 구현한 Collection 구현체이다.&lt;/p&gt;

&lt;p&gt;하지만 내부적으로 작동하는 방식은 다르다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Third&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Second&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//O(n)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;//O(n)&lt;/span&gt;
 
        &lt;span class=&quot;n&quot;&gt;alist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
 
        &lt;span class=&quot;n&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addFirst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Second&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addLast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Third&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pollFirst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pollLast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;//O(1)&lt;/span&gt;
 
        &lt;span class=&quot;n&quot;&gt;nlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;//O(n)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h2&gt;
&lt;p&gt;알고리즘 문제를 풀면서 가장 중요한 ArrayList와 LinkedList의 차이점은 시간복잡도의 차이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;ArrayList는 동적으로 Array를 생성한다고 생각하면 배열과 비슷한 점이 많다.&lt;/p&gt;

&lt;p&gt;ArrayList는 remove 시에 O(n)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;i번째 배열을 지우고 최대 n만큼 앞으로 이동해야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;&amp;lt; ArrayList 중간 Insert &amp;gt;
&lt;img src=&quot;/assets/images/ArrayList_insert.png&quot; alt=&quot;11st_result&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt; ArrayList 중간 Remove &amp;gt;
&lt;img src=&quot;/assets/images/ArrayList_insert.png&quot; alt=&quot;11st_result&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삽입 또한 맨 뒤에삽입과 중간삽입으로 나눌 수 있는데, 중간에 삽입하는 경우 O(n), 맨 뒤에 삽입하는 경우 O(1)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;하지만 get 메소드는 해당 index를 바로 가져오기 때문에 O(1)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;h2 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;&amp;lt; LinkedList 중간 add &amp;gt;
&lt;img src=&quot;/assets/images/LinkedList_add.png&quot; alt=&quot;11st_result&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이에 비해, LinkedList는 Node를 사용하기 때문에 add, poll 시에 O(1)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;하지만 get 메소드 사용시에 앞에서부터 찾기 때문에 O(n)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ArrayList&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;LinkedList&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;삽입&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;add&lt;br /&gt;O(1) or O(n)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;add, addFirst, addLast&lt;br /&gt;O(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;삭제&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;remove&lt;br /&gt;O(n)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;poll, pollFirst, pollLast&lt;br /&gt;O(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;접근&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;get&lt;br /&gt;O(1)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;get&lt;br /&gt;O(n)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>ChanSu Kim</name></author><category term="자료구조" /><category term="ArrayList" /><category term="LinkedList" /><category term="시간복잡도" /><summary type="html">ArrayList와 LinkedList ArrayList와 LinktedList 둘다 모두 Java에서 제공하는 List 인터페이스를 구현한 Collection 구현체이다. 하지만 내부적으로 작동하는 방식은 다르다. import java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws Exception { ArrayList&amp;lt;String&amp;gt; alist = new ArrayList&amp;lt;&amp;gt;(); alist.add(0,&quot;First&quot;); //O(1) alist.add(&quot;Third&quot;); //O(1) alist.add(1, &quot;Second&quot;); //O(n) alist.remove(1); //O(n) alist.get(1); //O(1) LinkedList&amp;lt;String&amp;gt; nlist = new LinkedList&amp;lt;&amp;gt;(); nlist.addFirst(&quot;First&quot;); //O(1) nlist.add(&quot;Second&quot;); //O(1) nlist.addLast(&quot;Third&quot;); //O(1) nlist.pollFirst(); //O(1) nlist.pollLast(); //O(1) nlist.get(0); //O(n) } } ArrayList 알고리즘 문제를 풀면서 가장 중요한 ArrayList와 LinkedList의 차이점은 시간복잡도의 차이라고 볼 수 있다. ArrayList는 동적으로 Array를 생성한다고 생각하면 배열과 비슷한 점이 많다. ArrayList는 remove 시에 O(n)의 시간복잡도를 가진다. i번째 배열을 지우고 최대 n만큼 앞으로 이동해야 하기 때문이다. &amp;lt; ArrayList 중간 Insert &amp;gt; &amp;lt; ArrayList 중간 Remove &amp;gt; 삽입 또한 맨 뒤에삽입과 중간삽입으로 나눌 수 있는데, 중간에 삽입하는 경우 O(n), 맨 뒤에 삽입하는 경우 O(1)의 시간복잡도를 가진다. 하지만 get 메소드는 해당 index를 바로 가져오기 때문에 O(1)의 시간복잡도를 가진다. LinkedList &amp;lt; LinkedList 중간 add &amp;gt; 이에 비해, LinkedList는 Node를 사용하기 때문에 add, poll 시에 O(1)의 시간복잡도를 가진다. 하지만 get 메소드 사용시에 앞에서부터 찾기 때문에 O(n)의 시간복잡도를 가진다. 정리   ArrayList LinkedList 삽입 addO(1) or O(n) add, addFirst, addLastO(1) 삭제 removeO(n) poll, pollFirst, pollLastO(1) 접근 getO(1) getO(n)</summary></entry><entry><title type="html">기억장치 관리</title><link href="http://localhost:4000/os/2019/05/20/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/" rel="alternate" type="text/html" title="기억장치 관리" /><published>2019-05-20T14:00:00+09:00</published><updated>2019-05-20T14:00:00+09:00</updated><id>http://localhost:4000/os/2019/05/20/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%20%EA%B4%80%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/os/2019/05/20/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/">&lt;h1 id=&quot;기억장치-배치-전략&quot;&gt;기억장치 배치 전략&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;최초 적합(First Fit) : 가능한 영역 중에서 첫 번째 분할 영역에 배치시키는 방법&lt;/li&gt;
  &lt;li&gt;최적 적합(Best Fit)  : 가능한 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치하는 방법&lt;/li&gt;
  &lt;li&gt;최악 적합(Worst Fit) : 가능한 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;영역번호&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;영역크기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;공백&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;공백&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용중&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;공백&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;공백&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;배치 전략 중 10K 프로그램이 할당 받는 영역의 번호는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최초 적합(First Fit) : 10K 프로그램이 들어갈 수 있는 첫 번째 영역은 2번이다.&lt;/li&gt;
  &lt;li&gt;최적 적합(Best Fit)  : 10K 프로그램이 들어가고 단편화를 가장 작게 남기는 영역은 4번이다.&lt;/li&gt;
  &lt;li&gt;최악 적합(Worst Fit) : 10K 프로그램이 들어가고 단편화를 가장 많이 남기는 영역은 5번이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;가상기억장치-구현&quot;&gt;가상기억장치 구현&lt;/h1&gt;
&lt;p&gt;보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸눈 &lt;strong&gt;주소 변환 작업(매핑)&lt;/strong&gt;이 필요하다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;페이징 기법 : 프로그램을 동일한 크기로 나눈 단위를 페이지라 하며 이 페이지를 블록으로 활용하는 기법&lt;/li&gt;
  &lt;li&gt;세그먼테이션 기법 : 프로그램을 가변적인 크기로 나눈 단위를 세그먼트라 하며, 이 세그먼트를 블록으로 사용하는 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cf)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;내부 단변화 : 프로그램이 할당된 후 남는 빈 공간, 영역 크기 16K &amp;gt; 프로그램 크기 14K 인 경우 내부 단편화 2K 발생&lt;/li&gt;
  &lt;li&gt;외부 단편화 : 영역 크기보다 프로그램 크기가 커서 할당되지 않아 남는 빈 공간, 영억 크기 12K &amp;lt; 프로그램 크기 14K 인 경우 외부 단편화 2K 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;페이징-기법&quot;&gt;페이징 기법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;페이지 : 프로그램을 일정한 크기로 나눈 단위(일반적으로 1~4KB)&lt;/li&gt;
  &lt;li&gt;프레임 : 페이지 크기로 일정하게 나누어진 주기억장치 단위&lt;/li&gt;
  &lt;li&gt;주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.&lt;/li&gt;
  &lt;li&gt;외부 단편화는 발생하지 않지만 내부 단편화는 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt; : 여러 개의 프로그램을 동시 실행할 수 있어 다중 프로그래밍 정도가 향상된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt; : 주소 변환 과정에서 CPU 사용시간이 낭비되고 내부 단편화 문제가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paging.png&quot; alt=&quot;paging&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세그먼테이션-기법&quot;&gt;세그먼테이션 기법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;세그먼트 : 사용자 주소 공간을 논리적인 단위로 나눈 것, 각 세그먼트는 고유한 이름과 크기를 가진다.&lt;/li&gt;
  &lt;li&gt;주소 변환을 위해 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt; : 외부단편화에 의한 기억장치 낭비를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt; : 세그먼트 크기가 가변적이기 때문에 세그먼트 영역이 다른 세그먼트 영역을 침범하지 않는 기억장치 보호키가 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/segment.png&quot; alt=&quot;paging&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h1&gt;
&lt;p&gt;페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재하는 데 어떤 프레임을 선택해 교체할 지 결정하는 기법&lt;/p&gt;

&lt;h2 id=&quot;fifofirst-in-first-out&quot;&gt;FIFO(First In First Out)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가장 오래 있었던 페이지를 고체하는 기법이다.&lt;/li&gt;
  &lt;li&gt;벨레이디의 모순 현상이 발생한다.(프레임 수가 늘어나면 페이지 부재 수가 줄어들지 않는 현상)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;참조 페이지&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 부재&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 경우 페이지 부재가 총 9번 발생한다.&lt;/p&gt;

&lt;p&gt;하지만, Frame 개수가 4개로 늘어나도 페이지 부재는 10번으로 증가한다. =&amp;gt; 벨레이디 모순 현상&lt;/p&gt;

&lt;h2 id=&quot;lruleast-recently-used&quot;&gt;LRU(Least Recently Used)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법&lt;/li&gt;
  &lt;li&gt;계수기나 스택같은 별로 하드웨어가 필요하며 시간적인 오버헤드가 발생하고, 실제로 구현하기 어렵다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;참조 페이지&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 부재&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;lfuleast-frequently-used&quot;&gt;LFU(Least Frequently Used)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;사용 빈도가 가장 적은 페이지를 교체하는 기법&lt;/li&gt;
  &lt;li&gt;활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.&lt;/li&gt;
  &lt;li&gt;초기에 많이 사용된 페이지가 그 후루도 사용되지 않을 경우 프레임을 계속 차지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;참조 페이지&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Frame 4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 부재&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;가상기억창치-관리&quot;&gt;가상기억창치 관리&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;페이지 크기
    &lt;ul&gt;
      &lt;li&gt;페이지 크기가 작을 경우
        &lt;ul&gt;
          &lt;li&gt;페이지 단편화가 가모되고 볼필요한 내용이 주기억장치에 적재될 확률이 적다.&lt;/li&gt;
          &lt;li&gt;페이지 정보를 가지는 페이지 맵 테이블 크기가 커지고 매핑 속도가 늦어진다.&lt;/li&gt;
          &lt;li&gt;디스크 접근 횟수가 많아져 전체적인 입출력 시간이 증가한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페이지 크기가 클 경우
        &lt;ul&gt;
          &lt;li&gt;페이지 정보를 갖는 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.&lt;/li&gt;
          &lt;li&gt;디스크 접근 횟수가 줄어들어 전체적인 입출력 시간이 감소한다.&lt;/li&gt;
          &lt;li&gt;페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구역성(Locality)
    &lt;ul&gt;
      &lt;li&gt;어느 순간 특정 페이지만 집중적으로 참조하는 것&lt;/li&gt;
      &lt;li&gt;시간 구역성
        &lt;ul&gt;
          &lt;li&gt;하나의 페이지를 일정 시간 동안 집중적으로 엑세스하는 현상&lt;/li&gt;
          &lt;li&gt;한번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공간 구역성
        &lt;ul&gt;
          &lt;li&gt;어느 하나의 페이지를 참조하면 그 근처의 페이지를 참조할 가능성이 높다.&lt;/li&gt;
          &lt;li&gt;프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;워킹 셋(Working Set)
    &lt;ul&gt;
      &lt;li&gt;프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합&lt;/li&gt;
      &lt;li&gt;자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 교체 현상이 줄어들어 사용이 안정화된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레싱(Thrashing)
    &lt;ul&gt;
      &lt;li&gt;프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상&lt;/li&gt;
      &lt;li&gt;어떤 프로세스가 실제로 사용하는 프레임 수만큼의 프레임을 갖지 못한 경우 발생&lt;/li&gt;
      &lt;li&gt;방지 방법 : 다중 프로그래밍 정도 완화, Working Set 이용&lt;/li&gt;
      &lt;li&gt;cf) 다중 프로그래밍 정도 : 얼마나 많은 프로그램을 동시에 수행하는 정도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;디스크-스케줄링&quot;&gt;디스크 스케줄링&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우 디스크 헤드가 움직으는 경로를 결정하는 기법&lt;/li&gt;
  &lt;li&gt;목적 : 처리량 최대화, 응답 시간 최소화, 응답 시간 편차의 최소화&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fcfsfirst-come-first-service&quot;&gt;FCFS(First Come First Service)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법&lt;/li&gt;
  &lt;li&gt;더 높은 우선순위의 요청이 입력되어도 순사가 바뀌지 않아 공평성이 보장된다.&lt;/li&gt;
  &lt;li&gt;디스크 오버헤드가 적을 때 효율적이며, 오버헤드가 커지면 응답 시간이 길어진다.&lt;/li&gt;
  &lt;li&gt;디스크 대기 큐 : 53,98,183,37,122,14,124,65,67&lt;/li&gt;
  &lt;li&gt;이동 순서 : 53 -&amp;gt; 98 -&amp;gt; 183 -&amp;gt; 37 -&amp;gt; 122 -&amp;gt; 14 -&amp;gt; 124 -&amp;gt; 65 -&amp;gt; 67&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sstfshortest-seek-time-first&quot;&gt;SSTF(Shortest Seek Time First)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법&lt;/li&gt;
  &lt;li&gt;현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동한다.&lt;/li&gt;
  &lt;li&gt;현재 헤드 위치에 가장 가까운 트랙에 대한 요청이 계속 발생하는 경우 먼 거리의 서비스는 무한정 기다리는 기아 상태가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;디스크 대기 큐 : 53,98,183,37,122,14,124,65,67&lt;/li&gt;
  &lt;li&gt;이동 순서 : 53 -&amp;gt; 65 -&amp;gt; 67 -&amp;gt; 37 -&amp;gt; 14 -&amp;gt; 98 -&amp;gt; 122 -&amp;gt; 124 -&amp;gt; 183&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scan&quot;&gt;SCAN&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법&lt;/li&gt;
  &lt;li&gt;현재 헤드 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스 후 역방향의 요청 사항을 서비스한다.&lt;/li&gt;
  &lt;li&gt;오버헤드가 적을 경우 가장 효율적인 기법이다.&lt;/li&gt;
  &lt;li&gt;디스크 대기 큐 : 53,98,183,37,122,14,124,65,67&lt;/li&gt;
  &lt;li&gt;이동 순서 : 53 -&amp;gt; 65 -&amp;gt; 67 -&amp;gt; 98 -&amp;gt; 122 -&amp;gt; 124 -&amp;gt; 183 -&amp;gt; 199 -&amp;gt; 37 -&amp;gt; 14&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;c-scancircular-scan&quot;&gt;C-SCAN(Circular SCAN)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;항상 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법&lt;/li&gt;
  &lt;li&gt;처음가 마지막을 인접시킨 것과 같은 원형 형태로 디스크를 처리한다.&lt;/li&gt;
  &lt;li&gt;디스크 대기 큐 : 53,98,183,37,122,14,124,65,67&lt;/li&gt;
  &lt;li&gt;이동 순서 : 53 -&amp;gt; 37 -&amp;gt; 14 -&amp;gt; 0 -&amp;gt; 199 -&amp;gt; 183 -&amp;gt; 124 -&amp;gt; 122 -&amp;gt; 98 -&amp;gt; 67 -&amp;gt; 65&lt;/li&gt;
&lt;/ul&gt;</content><author><name>ChanSu Kim</name></author><category term="OS" /><category term="기억장치" /><category term="메모리 할당" /><category term="페이징" /><category term="세그먼테이션" /><category term="디스크 스케쥴링" /><summary type="html">기억장치 배치 전략 최초 적합(First Fit) : 가능한 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 최적 적합(Best Fit) : 가능한 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치하는 방법 최악 적합(Worst Fit) : 가능한 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치하는 방법 영역번호 영역크기 상태 1 5K 공백 2 14K 공백 3 10K 사용중 4 12K 공백 5 16K 공백 배치 전략 중 10K 프로그램이 할당 받는 영역의 번호는 다음과 같다. 최초 적합(First Fit) : 10K 프로그램이 들어갈 수 있는 첫 번째 영역은 2번이다. 최적 적합(Best Fit) : 10K 프로그램이 들어가고 단편화를 가장 작게 남기는 영역은 4번이다. 최악 적합(Worst Fit) : 10K 프로그램이 들어가고 단편화를 가장 많이 남기는 영역은 5번이다. 가상기억장치 구현 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸눈 주소 변환 작업(매핑)이 필요하다. 페이징 기법 : 프로그램을 동일한 크기로 나눈 단위를 페이지라 하며 이 페이지를 블록으로 활용하는 기법 세그먼테이션 기법 : 프로그램을 가변적인 크기로 나눈 단위를 세그먼트라 하며, 이 세그먼트를 블록으로 사용하는 기법 cf) 내부 단변화 : 프로그램이 할당된 후 남는 빈 공간, 영역 크기 16K &amp;gt; 프로그램 크기 14K 인 경우 내부 단편화 2K 발생 외부 단편화 : 영역 크기보다 프로그램 크기가 커서 할당되지 않아 남는 빈 공간, 영억 크기 12K &amp;lt; 프로그램 크기 14K 인 경우 외부 단편화 2K 발생 페이징 기법 페이지 : 프로그램을 일정한 크기로 나눈 단위(일반적으로 1~4KB) 프레임 : 페이지 크기로 일정하게 나누어진 주기억장치 단위 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다. 외부 단편화는 발생하지 않지만 내부 단편화는 발생할 수 있다. 장점 : 여러 개의 프로그램을 동시 실행할 수 있어 다중 프로그래밍 정도가 향상된다. 단점 : 주소 변환 과정에서 CPU 사용시간이 낭비되고 내부 단편화 문제가 발생한다. 세그먼테이션 기법 세그먼트 : 사용자 주소 공간을 논리적인 단위로 나눈 것, 각 세그먼트는 고유한 이름과 크기를 가진다. 주소 변환을 위해 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다. 장점 : 외부단편화에 의한 기억장치 낭비를 줄일 수 있다. 단점 : 세그먼트 크기가 가변적이기 때문에 세그먼트 영역이 다른 세그먼트 영역을 침범하지 않는 기억장치 보호키가 필요하다. 페이지 교체 알고리즘 페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재하는 데 어떤 프레임을 선택해 교체할 지 결정하는 기법 FIFO(First In First Out) 가장 오래 있었던 페이지를 고체하는 기법이다. 벨레이디의 모순 현상이 발생한다.(프레임 수가 늘어나면 페이지 부재 수가 줄어들지 않는 현상) 참조 페이지 1 2 3 4 1 2 5 1 2 3 4 5 Frame 1 1 1 1 4 4 4 5 5 5 5 5 5 Frame 2   2 2 2 1 1 1 1 1 3 3 3 Frame 3     3 3 3 2 2 2 2 2 4 4 페이지 부재 O O O O O O O     O O   위 경우 페이지 부재가 총 9번 발생한다. 하지만, Frame 개수가 4개로 늘어나도 페이지 부재는 10번으로 증가한다. =&amp;gt; 벨레이디 모순 현상 LRU(Least Recently Used) 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법 계수기나 스택같은 별로 하드웨어가 필요하며 시간적인 오버헤드가 발생하고, 실제로 구현하기 어렵다. 참조 페이지 2 3 2 1 5 2 3 5 Frame 1 2 2 2 2 2 2 2 2 Frame 2   3 3 3 5 5 5 5 Frame 3       1 1 1 3 3 페이지 부재 O O   O O   O   LFU(Least Frequently Used) 사용 빈도가 가장 적은 페이지를 교체하는 기법 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다. 초기에 많이 사용된 페이지가 그 후루도 사용되지 않을 경우 프레임을 계속 차지할 수 있다. 참조 페이지 2 3 1 3 1 2 4 5 Frame 1 2 2 2 2 2 2 2 2 Frame 2   3 3 3 3 3 3 3 Frame 3     1 1 1 1 1 1 Frame 4             4 5 페이지 부재 O O O       O O 가상기억창치 관리 페이지 크기 페이지 크기가 작을 경우 페이지 단편화가 가모되고 볼필요한 내용이 주기억장치에 적재될 확률이 적다. 페이지 정보를 가지는 페이지 맵 테이블 크기가 커지고 매핑 속도가 늦어진다. 디스크 접근 횟수가 많아져 전체적인 입출력 시간이 증가한다. 페이지 크기가 클 경우 페이지 정보를 갖는 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다. 디스크 접근 횟수가 줄어들어 전체적인 입출력 시간이 감소한다. 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다. 구역성(Locality) 어느 순간 특정 페이지만 집중적으로 참조하는 것 시간 구역성 하나의 페이지를 일정 시간 동안 집중적으로 엑세스하는 현상 한번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높다. 공간 구역성 어느 하나의 페이지를 참조하면 그 근처의 페이지를 참조할 가능성이 높다. 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상 워킹 셋(Working Set) 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 교체 현상이 줄어들어 사용이 안정화된다. 스레싱(Thrashing) 프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상 어떤 프로세스가 실제로 사용하는 프레임 수만큼의 프레임을 갖지 못한 경우 발생 방지 방법 : 다중 프로그래밍 정도 완화, Working Set 이용 cf) 다중 프로그래밍 정도 : 얼마나 많은 프로그램을 동시에 수행하는 정도 디스크 스케줄링 사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우 디스크 헤드가 움직으는 경로를 결정하는 기법 목적 : 처리량 최대화, 응답 시간 최소화, 응답 시간 편차의 최소화 FCFS(First Come First Service) 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법 더 높은 우선순위의 요청이 입력되어도 순사가 바뀌지 않아 공평성이 보장된다. 디스크 오버헤드가 적을 때 효율적이며, 오버헤드가 커지면 응답 시간이 길어진다. 디스크 대기 큐 : 53,98,183,37,122,14,124,65,67 이동 순서 : 53 -&amp;gt; 98 -&amp;gt; 183 -&amp;gt; 37 -&amp;gt; 122 -&amp;gt; 14 -&amp;gt; 124 -&amp;gt; 65 -&amp;gt; 67 SSTF(Shortest Seek Time First) 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동한다. 현재 헤드 위치에 가장 가까운 트랙에 대한 요청이 계속 발생하는 경우 먼 거리의 서비스는 무한정 기다리는 기아 상태가 발생할 수 있다. 디스크 대기 큐 : 53,98,183,37,122,14,124,65,67 이동 순서 : 53 -&amp;gt; 65 -&amp;gt; 67 -&amp;gt; 37 -&amp;gt; 14 -&amp;gt; 98 -&amp;gt; 122 -&amp;gt; 124 -&amp;gt; 183 SCAN SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법 현재 헤드 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스 후 역방향의 요청 사항을 서비스한다. 오버헤드가 적을 경우 가장 효율적인 기법이다. 디스크 대기 큐 : 53,98,183,37,122,14,124,65,67 이동 순서 : 53 -&amp;gt; 65 -&amp;gt; 67 -&amp;gt; 98 -&amp;gt; 122 -&amp;gt; 124 -&amp;gt; 183 -&amp;gt; 199 -&amp;gt; 37 -&amp;gt; 14 C-SCAN(Circular SCAN) 항상 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법 처음가 마지막을 인접시킨 것과 같은 원형 형태로 디스크를 처리한다. 디스크 대기 큐 : 53,98,183,37,122,14,124,65,67 이동 순서 : 53 -&amp;gt; 37 -&amp;gt; 14 -&amp;gt; 0 -&amp;gt; 199 -&amp;gt; 183 -&amp;gt; 124 -&amp;gt; 122 -&amp;gt; 98 -&amp;gt; 67 -&amp;gt; 65</summary></entry><entry><title type="html">운영체제와 CPU 스케쥴링</title><link href="http://localhost:4000/os/2019/05/19/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/" rel="alternate" type="text/html" title="운영체제와 CPU 스케쥴링" /><published>2019-05-19T17:00:00+09:00</published><updated>2019-05-19T17:00:00+09:00</updated><id>http://localhost:4000/os/2019/05/19/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80%20CPU%20%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/os/2019/05/19/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/">&lt;h1 id=&quot;운영체제란&quot;&gt;운영체제란?&lt;/h1&gt;
&lt;p&gt;제한된 컴퓨터 각종 자원을 효율적으로 관리하여 사용자에게 편리한 환경을 제공하는 소프트웨어&lt;/p&gt;

&lt;h2 id=&quot;운영체제-목적&quot;&gt;운영체제 목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양&lt;/li&gt;
  &lt;li&gt;반환 시간 : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 소요되는 시간&lt;/li&gt;
  &lt;li&gt;사용 가능도 : 시스템 사용할 필요가 있을 때 즉시 가용 가능한 정도&lt;/li&gt;
  &lt;li&gt;신뢰도 : 시스템이 주어진 문제를 정확하게 해결하는 정도&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;운영체제-기능&quot;&gt;운영체제 기능&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서 관리&lt;/li&gt;
  &lt;li&gt;기억장치 관리&lt;/li&gt;
  &lt;li&gt;프로세스 관리&lt;/li&gt;
  &lt;li&gt;주변장치 관리&lt;/li&gt;
  &lt;li&gt;파일 및 데이터 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로세스&quot;&gt;프로세스&lt;/h2&gt;
&lt;p&gt;현재 실행중이거나 곧 실행 가능한 PCB를 가진 프로그램&lt;/p&gt;

&lt;p&gt;cf) PCB(Process Control Block) : OS가 프로세스의 대한 중요한 정보를 저장하는 곳으로 각 프로세스가 생성될 때 고유 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/process.png&quot; alt=&quot;memory&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스레드thread&quot;&gt;스레드(Thread)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위&lt;/li&gt;
  &lt;li&gt;스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스 역할 담당&lt;/li&gt;
  &lt;li&gt;하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h1&gt;
&lt;p&gt;프로세스가 생성되어 실행될 때 필요한 시스템의 자원을 해당 프로세스에 할당하는 것&lt;/p&gt;

&lt;p&gt;cf) 문맥 교환(Context Switching) : 하나의 프로세스에서 다른 프로세스로 전환할 때 실행하던 프로세스의 상태를 보관하고 새로운 프로세스 정보를 적재하여 실행을 준비하는 것&lt;/p&gt;

&lt;p&gt;cf) 준비상태 큐(Ready Queue) : 주기억장치에 적재되어 있으면서 CPU에 의해 실행되기를 준비하는 프로세스들로 구성된 리스트&lt;/p&gt;

&lt;h2 id=&quot;비선점-스케쥴링&quot;&gt;비선점 스케쥴링&lt;/h2&gt;
&lt;p&gt;이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법&lt;/p&gt;

&lt;p&gt;프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.&lt;/p&gt;

&lt;p&gt;프로세스의 요구를 공정하게 처리할 수 있지만 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;fcfsfirst-come-first-service&quot;&gt;FCFS(First Come First Service)&lt;/h3&gt;
&lt;p&gt;준비상태 큐에 먼저 도착한 순서대로 CPU에 할당하는 기법&lt;/p&gt;

&lt;p&gt;공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;sjfshort-job-first&quot;&gt;SJF(Short Job First)&lt;/h3&gt;
&lt;p&gt;준비상태 큐에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법&lt;/p&gt;

&lt;p&gt;실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 할당 순위가 밀려 무한 연기(기아) 상태가 발생할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;hrnhightest-response-ratio-next&quot;&gt;HRN(Hightest Response-ratio Next)&lt;/h3&gt;
&lt;p&gt;SJF 기법을 보완한 것으로 대기 중인 프로세스들의 대기시간과 실행시간을 고려하여 우선순위를 결정한다.&lt;/p&gt;

&lt;p&gt;우선순위 계산식 : (대기시간 + 수행시간) / 수행시간&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;선점-스케쥴링&quot;&gt;선점 스케쥴링&lt;/h2&gt;
&lt;p&gt;하나의 프로세스가 CPU를 할당받아 실행중일 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케쥴링 기법&lt;/p&gt;

&lt;p&gt;우선순위가 높은 프로세스를 빠르게 처리할 수 있지만 많은 Overhead를 초래한다.&lt;/p&gt;

&lt;h3 id=&quot;round--robin&quot;&gt;Round  Robin&lt;/h3&gt;
&lt;p&gt;각 프로세스느 시간 할당량(Time Slice)만큼 CPU를 점유하고 실행이 완료되지 않으면 CPU를 반환하고 준비상태 큐의 가장 뒤로 배치&lt;/p&gt;

&lt;p&gt;문맥 교환(Context Switching) 효과를 고려하여 시간 할당량을 정한다.&lt;/p&gt;

&lt;p&gt;시간 할당량이 클수록 FCFS와 같아지고, 시간 할당량이 작을 수록 문맥 교환 및 오버헤드가 자주발생&lt;/p&gt;

&lt;h3 id=&quot;srtshortest-remaining-time&quot;&gt;SRT(Shortest Remaining Time)&lt;/h3&gt;
&lt;p&gt;SJF 기법을 선점 형태로 변경한 기법으로 프로세스들 중 남아있는 실행시간이 가장 짧은 프로세스를 다음 프로세스로 선택&lt;/p&gt;

&lt;h3 id=&quot;다단계-큐-스케쥴링&quot;&gt;다단계 큐 스케쥴링&lt;/h3&gt;
&lt;p&gt;준비완료 큐를 다수의 별도의 큐로 분리하여 각 큐의 독자적인 스케쥴링에 따라 CPU를 할당받는 기법&lt;/p&gt;

&lt;p&gt;각각의 서로 다른 작업들이 다른 묶음으로 분리될 수 있을 때 사용한다.&lt;/p&gt;

&lt;p&gt;이전 작업이 실행 중이더라도 우선 순위가 높은 큐에 작업이 들어오면 CPU를 반환해야 한다.&lt;/p&gt;

&lt;p&gt;cf) 우선순위 : 시스템 프로세스 &amp;gt; 대화형 프로세스 &amp;gt; 일괄처리 프로세스&lt;/p&gt;

&lt;h3 id=&quot;다단계-피드백-큐-스케쥴링&quot;&gt;다단계 피드백 큐 스케쥴링&lt;/h3&gt;
&lt;p&gt;프로세스가 큐들 사이를 이동하는 것을 허용하는 기법이다.&lt;/p&gt;

&lt;p&gt;프로세스를 CPU 성격에 따라 구분하고 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 한 단계 낮은 우선순위 준비큐로 강등된다.&lt;/p&gt;

&lt;p&gt;즉, 짧은 프로세스의 경우 FCFS 방식으로 신속하게 실행되고, 긴 프로세스는 낮은 단계의 준비단계 큐로 밀린다.&lt;/p&gt;

&lt;p&gt;낮은 우선순위 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동한다. (Aging 기법) -&amp;gt; 기아 상태 예방&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="OS" /><category term="프로세스" /><category term="스레드" /><category term="비선점 스케쥴링" /><category term="선점 스케쥴링" /><summary type="html">운영체제란? 제한된 컴퓨터 각종 자원을 효율적으로 관리하여 사용자에게 편리한 환경을 제공하는 소프트웨어 운영체제 목적 처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양 반환 시간 : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 소요되는 시간 사용 가능도 : 시스템 사용할 필요가 있을 때 즉시 가용 가능한 정도 신뢰도 : 시스템이 주어진 문제를 정확하게 해결하는 정도 운영체제 기능 프로세서 관리 기억장치 관리 프로세스 관리 주변장치 관리 파일 및 데이터 관리 프로세스 현재 실행중이거나 곧 실행 가능한 PCB를 가진 프로그램 cf) PCB(Process Control Block) : OS가 프로세스의 대한 중요한 정보를 저장하는 곳으로 각 프로세스가 생성될 때 고유 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다. 스레드(Thread) 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스 역할 담당 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다. 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다. CPU 스케줄링 프로세스가 생성되어 실행될 때 필요한 시스템의 자원을 해당 프로세스에 할당하는 것 cf) 문맥 교환(Context Switching) : 하나의 프로세스에서 다른 프로세스로 전환할 때 실행하던 프로세스의 상태를 보관하고 새로운 프로세스 정보를 적재하여 실행을 준비하는 것 cf) 준비상태 큐(Ready Queue) : 주기억장치에 적재되어 있으면서 CPU에 의해 실행되기를 준비하는 프로세스들로 구성된 리스트 비선점 스케쥴링 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다. 프로세스의 요구를 공정하게 처리할 수 있지만 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생한다. FCFS(First Come First Service) 준비상태 큐에 먼저 도착한 순서대로 CPU에 할당하는 기법 공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 된다. SJF(Short Job First) 준비상태 큐에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 할당 순위가 밀려 무한 연기(기아) 상태가 발생할 수 있다. HRN(Hightest Response-ratio Next) SJF 기법을 보완한 것으로 대기 중인 프로세스들의 대기시간과 실행시간을 고려하여 우선순위를 결정한다. 우선순위 계산식 : (대기시간 + 수행시간) / 수행시간 선점 스케쥴링 하나의 프로세스가 CPU를 할당받아 실행중일 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케쥴링 기법 우선순위가 높은 프로세스를 빠르게 처리할 수 있지만 많은 Overhead를 초래한다. Round Robin 각 프로세스느 시간 할당량(Time Slice)만큼 CPU를 점유하고 실행이 완료되지 않으면 CPU를 반환하고 준비상태 큐의 가장 뒤로 배치 문맥 교환(Context Switching) 효과를 고려하여 시간 할당량을 정한다. 시간 할당량이 클수록 FCFS와 같아지고, 시간 할당량이 작을 수록 문맥 교환 및 오버헤드가 자주발생 SRT(Shortest Remaining Time) SJF 기법을 선점 형태로 변경한 기법으로 프로세스들 중 남아있는 실행시간이 가장 짧은 프로세스를 다음 프로세스로 선택 다단계 큐 스케쥴링 준비완료 큐를 다수의 별도의 큐로 분리하여 각 큐의 독자적인 스케쥴링에 따라 CPU를 할당받는 기법 각각의 서로 다른 작업들이 다른 묶음으로 분리될 수 있을 때 사용한다. 이전 작업이 실행 중이더라도 우선 순위가 높은 큐에 작업이 들어오면 CPU를 반환해야 한다. cf) 우선순위 : 시스템 프로세스 &amp;gt; 대화형 프로세스 &amp;gt; 일괄처리 프로세스 다단계 피드백 큐 스케쥴링 프로세스가 큐들 사이를 이동하는 것을 허용하는 기법이다. 프로세스를 CPU 성격에 따라 구분하고 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 한 단계 낮은 우선순위 준비큐로 강등된다. 즉, 짧은 프로세스의 경우 FCFS 방식으로 신속하게 실행되고, 긴 프로세스는 낮은 단계의 준비단계 큐로 밀린다. 낮은 우선순위 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동한다. (Aging 기법) -&amp;gt; 기아 상태 예방</summary></entry><entry><title type="html">Stack 영역과 Heap 영역</title><link href="http://localhost:4000/java/2019/05/19/Stack-%EC%98%81%EC%97%AD%EA%B3%BC-Heap-%EC%98%81%EC%97%AD/" rel="alternate" type="text/html" title="Stack 영역과 Heap 영역" /><published>2019-05-19T17:00:00+09:00</published><updated>2019-05-19T17:00:00+09:00</updated><id>http://localhost:4000/java/2019/05/19/Stack%20%EC%98%81%EC%97%AD%EA%B3%BC%20Heap%20%EC%98%81%EC%97%AD</id><content type="html" xml:base="http://localhost:4000/java/2019/05/19/Stack-%EC%98%81%EC%97%AD%EA%B3%BC-Heap-%EC%98%81%EC%97%AD/">&lt;h1 id=&quot;stack-영역&quot;&gt;Stack 영역&lt;/h1&gt;
&lt;p&gt;프로그램 실행 과정에서 메소드 실행 시 임시로 할당되고 해당 메소드가 끝나면 바로 소멸되는 것들이 저장된다.&lt;/p&gt;

&lt;p&gt;Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다.&lt;/p&gt;

&lt;h1 id=&quot;heap-영역&quot;&gt;Heap 영역&lt;/h1&gt;
&lt;p&gt;Java에서 new 명령을 통해 생성된 인스턴스 변수가 놓인다.&lt;/p&gt;

&lt;p&gt;모든 Object 타입(Integer, String, ArrayList, …)은 heap 영역에 생성된다.&lt;/p&gt;

&lt;p&gt;GC에 의해 지위지지 않는 이상 Heap 영역에 계속 남아있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 코드가 있다고 가정했을 때, 해당하는 Stack 영역과 Heap 영역은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/memory.png&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack 영역에는 Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다.&lt;/p&gt;

&lt;p&gt;만약, 여기서 host += :8080 이라는 코드를 추가하면, localhost에 값이 추가되는 것이 아니라 localhost:8080 라는 새로운 String Object가 할당되어 참조하게 된다.&lt;/p&gt;

&lt;p&gt;즉, localhost는 unreachable 객체가 되어 GC에 의해 메모리에서 제거된다.&lt;/p&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://yaboong.github.io/java/2018/05/26/java-memory-management/&quot;&gt;https://yaboong.github.io/java/2018/05/26/java-memory-management/&lt;/a&gt;&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="Java" /><category term="Stack Area" /><category term="Heap Area" /><summary type="html">Stack 영역 프로그램 실행 과정에서 메소드 실행 시 임시로 할당되고 해당 메소드가 끝나면 바로 소멸되는 것들이 저장된다. Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다. Heap 영역 Java에서 new 명령을 통해 생성된 인스턴스 변수가 놓인다. 모든 Object 타입(Integer, String, ArrayList, …)은 heap 영역에 생성된다. GC에 의해 지위지지 않는 이상 Heap 영역에 계속 남아있다. public class Main { public static void main(String[] args) { int port = 4000; String host = &quot;localhost&quot;; } } 위와 같은 코드가 있다고 가정했을 때, 해당하는 Stack 영역과 Heap 영역은 다음과 같다. Stack 영역에는 Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다. 만약, 여기서 host += :8080 이라는 코드를 추가하면, localhost에 값이 추가되는 것이 아니라 localhost:8080 라는 새로운 String Object가 할당되어 참조하게 된다. 즉, localhost는 unreachable 객체가 되어 GC에 의해 메모리에서 제거된다. 참고 : https://yaboong.github.io/java/2018/05/26/java-memory-management/</summary></entry><entry><title type="html">프로세스 동기화</title><link href="http://localhost:4000/os/2019/05/19/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/" rel="alternate" type="text/html" title="프로세스 동기화" /><published>2019-05-19T17:00:00+09:00</published><updated>2019-05-19T17:00:00+09:00</updated><id>http://localhost:4000/os/2019/05/19/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94</id><content type="html" xml:base="http://localhost:4000/os/2019/05/19/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/">&lt;h1 id=&quot;프로세스-동기화-배경&quot;&gt;프로세스 동기화 배경&lt;/h1&gt;
&lt;p&gt;프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성이 유지되어야 한다.&lt;/p&gt;

&lt;p&gt;병행 프로세스는 다중 처리 시스템이나 분산 처리 시스템에서 중요 개념으로 사용&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;임계-구역&quot;&gt;임계 구역&lt;/h1&gt;
&lt;p&gt;한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다.&lt;/p&gt;

&lt;p&gt;임계구역 안에서는 공유 변수를 변경, 테이블 갱신, 파일 쓰기 등의 작업을 수행한다.&lt;/p&gt;

&lt;p&gt;임계구역에는 하나의 프로세스만 접근할 수 있으며, 해당 프로세스가 자원을 반납해야 다른 프로세스가 자원 및 데이터를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;임계구역 문제 해결 방법&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;상호 배제 기법
특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법
    &lt;ul&gt;
      &lt;li&gt;두 개의 프로세스 기준 : 피터슨 알고리즘(두 프로세스가 두 개의 데이터 항목을 공유하여 자원을 사용하는 방법)&lt;/li&gt;
      &lt;li&gt;여러 개의 프로세스 기준 : Lamport의 빵집 알고리즘(각 프로세스에 번호를 부여하여 자원을 사용하도록 하는 방볍)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;진행
자신의 임계구역에서 실행되는 프로세스가 없고 자신의 임계구역으로 진입하려는 프로세스가 있다면 잔류 구역에서 실행 중이지 않은 프로세스들만 임계영역에 진입 대상이 되고, 이 선택은 무한정 연기되지 않음!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한계 대기
프로세스가 자기의 임계구역에 진입하려는 요청을 한 후로부터 요청이 허용될 때까지 다른 프로세스들이 임계영역에 그들 자신의 임계구역에 진입을 허용하는 횟수의 한계가 필요하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mutex-lock상호-배재&quot;&gt;Mutex Lock(상호 배재)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/mutex.png&quot; alt=&quot;mutex&quot; width=&quot;400&quot; /&gt;
Mutex가 지켜주는 덕에 화장실을 한명만 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;즉, Mutex는 임계구역을 보호하고 프로세스간 경쟁을 방지하기 위해 사용&lt;/p&gt;

&lt;p&gt;boolean available 변수를 사용 =&amp;gt; 락의 가용 여부 표시&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Lock 획득
&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;임계구역&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Lock 반환
&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;나머지&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;구역&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;세마포어semaphore&quot;&gt;세마포어(Semaphore)&lt;/h2&gt;
&lt;p&gt;Mutex와 유사하게 동작하지만 프로세스들이 자신들의 행동을 더 정교하게 동기화 할 수 있는 방법 제공&lt;/p&gt;

&lt;p&gt;각 프로세스에 제어신호를 전달하여 순차적으로 진행하기 위한 동기화 구현&lt;/p&gt;

&lt;p&gt;세마포 S = 정수 변수, wait(s)와 signal(s)로만 접근이 가능하다. S = 0인 경우 모든 자원이 사용 중을 의미&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//wait(S) =&amp;gt; 상호배재 보장
//임계구역에 진입하기 전에 확인
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//누군가 사용하고 있다면
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;양수가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;될&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;때까지&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;현재&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;프로세스를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에서&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기다림&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//임계 구역에 진입이 가능하다면
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Signal(S) =&amp;gt; 진행 보장
//임계구역을 떠날 때 실행
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;자원&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;반환전에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에서&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기다리는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;프로세스가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있다면&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;그&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;중&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;한개&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;프로세스를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;임계&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;구역&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;진입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//list에서 기다리는 프로세스가 없다면
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mutex와-세마포어의-차이&quot;&gt;Mutex와 세마포어의 차이&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mutex(상호 배재)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Critical Section을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술&lt;/li&gt;
  &lt;li&gt;Mutex 객체를 두 쓰레드가 동시에 사용할 수 없다. (1개의 쓰레드만 Critical Section에 접근 가능하도록 하는 기술)
cf) Critical Section : 각 프로세스에서 공유데이터를 엑세스하는 프로그램 코드부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;세마포어(Semaphore)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것&lt;/li&gt;
  &lt;li&gt;만약, 화장실 칸이 4개라면 4개의 프로세스는 사용 가능하고, 나머지 프로세스는 대기해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;고전적인-동기화-문제&quot;&gt;고전적인 동기화 문제&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;생산자-소비자 문제
 생산자가 데이터를 생산하여 입력된 경우에만 접근하도록 구성하는 방식&lt;/p&gt;

    &lt;p&gt;생산자는 꽉찬 버퍼를 생산하고 소비자는 비어있는 버퍼를 생산한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;읽기-쓰기 문제
 두 Reader가 동시에 공유 데이터를 접근하는 것은 허용하나, 동시에 Writer를 허용하지 않는 방식&lt;/p&gt;

    &lt;p&gt;Writer보다 Reader 요청이 많은 경우 병행성을 높일 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;식사하는 철학자 문제
 5명의 철학자들은 생각하고 먹는 일을 수행(철학자 : 프로세스, 젓가락 : 자원)&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;철학자는 양쪽의 젓가락을 사용하여 식사를 하고, 식사를 마친 철학자는 젓가락을 내려놓고 다시 생각한다.&lt;/li&gt;
      &lt;li&gt;철학자는 2개의 젓가락을 손에 쥐어야 식사를 할 수 있고, 한 번에 하나씩 잡을 수 있다.&lt;/li&gt;
      &lt;li&gt;옆 사람이 식사중이면 젓가락 잡는 것을 대기한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5명의 철학자가 동시에 식사를 하게 되면 모두 왼쪽 포크만을 가지게 되고 오른쪽 포크를 대기하는 교착 상태(Deadlock)이 발생한다.&lt;/p&gt;

&lt;p&gt;이를 방지하기 위한 방법은 대표적으로 3가지이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최대 4명의 철학자들만이 테이블에 앉을 수 있도록 한다. =&amp;gt; 젓가락이 하나 남기 때문에 어떤 철학자는 식사가 가능하다.&lt;/li&gt;
  &lt;li&gt;한 철학자가 동시에 두개의 젓가락을 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.(즉, 임계구역 안에서만 젓가락을 집어야 한다)&lt;/li&gt;
  &lt;li&gt;비대칭 해결안을 사용한다.(홀수 번 철학자는 왼쪽, 짝수 번 철학자는 오른쪽 젓가락부터 집는다)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;교착상태deadlock&quot;&gt;교착상태(DeadLock)&lt;/h1&gt;
&lt;p&gt;상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상&lt;/p&gt;

&lt;h2 id=&quot;예방-기법&quot;&gt;예방 기법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상호 배재 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.&lt;/li&gt;
  &lt;li&gt;점유 및 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당해 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다.&lt;/li&gt;
  &lt;li&gt;비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구 자원을 사용하기 위해 기다리게 한다.&lt;/li&gt;
  &lt;li&gt;환형 대기 부정 : 자원을 선형 순서로 분류해 고유 번호를 할당하고, 각 프로세스는 현재 점유한 고유 번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회피-기법dijkstra-제안한-은행원-알고리즘&quot;&gt;회피 기법(Dijkstra 제안한 은행원 알고리즘)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;안정 상태 : 모든 프로세스가 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태&lt;/li&gt;
  &lt;li&gt;불안정 상태 : 교착상태의 필수 조건으로 교착상태가 발생할 수 있는 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;은행원 알고리즘 : 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 프로세스마다 할당할 수 있는 최대 자원을 계산한다.&lt;/li&gt;
  &lt;li&gt;각 프로세스마다 자원을 할당한 후에도 안전 상태를 유지할 수 있는지 확인하고 자원을 할당한다.&lt;/li&gt;
  &lt;li&gt;추가적인 자원을 할당해도 안전 상태를 유지할 수 있다면 자원을 할당할 수 있다. 하지만 불안전상태가 된다면 교착상태가 되므로 거절한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Available : 각 종류별로 가용한 자원의 개수, Available[i] = k 라면 R[i] 를 K개 사용할 수 있다는 뜻&lt;/li&gt;
  &lt;li&gt;Max : 각 프로세스가 최대로 필요로 하는 자원의 개수, Max[i,j] = k 라면 Process[i]가 R[j]를 K개까지 요청할 수 있다는 뜻&lt;/li&gt;
  &lt;li&gt;Allocation : 각 프로세스에게 현재 나가있는 자원의 개수, Allocation[i,j] = k 라면 현재 Process[i]가 R[j]를 K개 사용 중이라는 뜻&lt;/li&gt;
  &lt;li&gt;Need : 각 프로세스가 향후 요청할 수 있는 자원의 개수, Need[i,j] = k라면 Process[i]가 향후 R[j]를 K개 요청할 수 있다는 뜻
    &lt;ul&gt;
      &lt;li&gt;Need = Max - Allocation&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자원-요청-알고리즘&quot;&gt;자원 요청 알고리즘&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;만약 &lt;strong&gt;Request[i] &amp;lt;= Need[i]&lt;/strong&gt; 이면 2단계로 이동, 아니면 시스템에 있는 개수보다 더 많이 요청했기 때문에 오류로 처리&lt;/li&gt;
  &lt;li&gt;만약 &lt;strong&gt;Request[i] &amp;lt;= Available[i]&lt;/strong&gt; 이면 3단꼐로 이동, 아니면 요청한 자원이 지금 없으므로 Process[i]는 기다려야 한다.&lt;/li&gt;
  &lt;li&gt;Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다.
    &lt;ul&gt;
      &lt;li&gt;Available = Available - Request[i]&lt;/li&gt;
      &lt;li&gt;Allocation[i] = Allocation[i] + Request[i]&lt;/li&gt;
      &lt;li&gt;Need[i] = Need[i] - Request[i]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;만약, 이렇게 바뀐 상태가 안전하다면 Process[i]에게 자원을 할당한다. 그렇지 않다면 상태를 원상태로 되돌리고 Request[i]가 만족될 때까지 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 통해 알아보자. 프로세스 P와 A 자원 10개, B 자원 5개, C 자원 7개가 있을 때 다음과 같은 예시가 있다고 가정하자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Allocation&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Max&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Need&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Type&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P[0]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P[1]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P[2]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P[3]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P[4]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Need 값은 Max - Allocation 으로 구할 수 있으며 이 경우 남은 자원 수는 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Available&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10 - (0+2+3+2+0) = 3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5 - (1+0+0+1+0) = 3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7 - (0+0+2+1+2) = 2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;여기서 P[1]이 A 자원 1개와 C 자원 2개를 추가로 요청한다고 가정해보자. 이 때의 Request[1] = (1,0,2) 가 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Request[i] &amp;lt;= Need[i]&lt;/strong&gt;를 검사한다. (1,0,2) &amp;lt;= (1,2,2)이므로 조건을 만족한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Request[i] &amp;lt;= Available[i]&lt;/strong&gt;를 검사한다. (1,0,2) &amp;lt;= (3,3,2) 이므로 조건을 만족한다.&lt;/li&gt;
  &lt;li&gt;Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다.
    &lt;ul&gt;
      &lt;li&gt;Available[1] = Available[1] (3,3,2) - Request[1] (1,0,2) = (2,3,0)&lt;/li&gt;
      &lt;li&gt;Allocation[1] = Allocation[1] (2,0,0) + Request[1] (1,0,2) = (3,0,2)&lt;/li&gt;
      &lt;li&gt;Need[1] = Need[1] (1,2,2) - Request[1] (1,0,2) = (0,2,0)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위 상태는 안정 상태이므로 Process[1] 의 요청을 즉시 들어줄 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 예시에서는 &lt;strong&gt;&amp;lt;P[1], P[3], P[4], P[2], P[0]&amp;gt;&lt;/strong&gt; 순서로 진행하면 안정 순서열이 된다.&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="OS" /><category term="프로세스 동기화" /><category term="Mutex" /><category term="Semaphore" /><category term="뮤텍스" /><category term="세마포어" /><category term="데드락" /><category term="은행원 알고리즘" /><summary type="html">프로세스 동기화 배경 프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성이 유지되어야 한다. 병행 프로세스는 다중 처리 시스템이나 분산 처리 시스템에서 중요 개념으로 사용 임계 구역 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다. 임계구역 안에서는 공유 변수를 변경, 테이블 갱신, 파일 쓰기 등의 작업을 수행한다. 임계구역에는 하나의 프로세스만 접근할 수 있으며, 해당 프로세스가 자원을 반납해야 다른 프로세스가 자원 및 데이터를 사용할 수 있다. 임계구역 문제 해결 방법 상호 배제 기법 특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법 두 개의 프로세스 기준 : 피터슨 알고리즘(두 프로세스가 두 개의 데이터 항목을 공유하여 자원을 사용하는 방법) 여러 개의 프로세스 기준 : Lamport의 빵집 알고리즘(각 프로세스에 번호를 부여하여 자원을 사용하도록 하는 방볍) 진행 자신의 임계구역에서 실행되는 프로세스가 없고 자신의 임계구역으로 진입하려는 프로세스가 있다면 잔류 구역에서 실행 중이지 않은 프로세스들만 임계영역에 진입 대상이 되고, 이 선택은 무한정 연기되지 않음! 한계 대기 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후로부터 요청이 허용될 때까지 다른 프로세스들이 임계영역에 그들 자신의 임계구역에 진입을 허용하는 횟수의 한계가 필요하다. Mutex Lock(상호 배재) Mutex가 지켜주는 덕에 화장실을 한명만 사용할 수 있다. 즉, Mutex는 임계구역을 보호하고 프로세스간 경쟁을 방지하기 위해 사용 boolean available 변수를 사용 =&amp;gt; 락의 가용 여부 표시 do { //Lock 획득 임계구역 //Lock 반환 나머지 구역 } while(true); 세마포어(Semaphore) Mutex와 유사하게 동작하지만 프로세스들이 자신들의 행동을 더 정교하게 동기화 할 수 있는 방법 제공 각 프로세스에 제어신호를 전달하여 순차적으로 진행하기 위한 동기화 구현 세마포 S = 정수 변수, wait(s)와 signal(s)로만 접근이 가능하다. S = 0인 경우 모든 자원이 사용 중을 의미 //wait(S) =&amp;gt; 상호배재 보장 //임계구역에 진입하기 전에 확인 if (S &amp;lt;= 0) //누군가 사용하고 있다면 S가 양수가 될 때까지 현재 프로세스를 list에서 기다림 else //임계 구역에 진입이 가능하다면 S = S - 1; //Signal(S) =&amp;gt; 진행 보장 //임계구역을 떠날 때 실행 if (자원 반환전에 list에서 기다리는 프로세스가 있다면) 그 중 한개 프로세스를 임계 구역 진입 else //list에서 기다리는 프로세스가 없다면 S = S + 1; Mutex와 세마포어의 차이 Mutex(상호 배재) Critical Section을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술 Mutex 객체를 두 쓰레드가 동시에 사용할 수 없다. (1개의 쓰레드만 Critical Section에 접근 가능하도록 하는 기술) cf) Critical Section : 각 프로세스에서 공유데이터를 엑세스하는 프로그램 코드부분 세마포어(Semaphore) 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것 만약, 화장실 칸이 4개라면 4개의 프로세스는 사용 가능하고, 나머지 프로세스는 대기해야 한다. 고전적인 동기화 문제 생산자-소비자 문제 생산자가 데이터를 생산하여 입력된 경우에만 접근하도록 구성하는 방식 생산자는 꽉찬 버퍼를 생산하고 소비자는 비어있는 버퍼를 생산한다. 읽기-쓰기 문제 두 Reader가 동시에 공유 데이터를 접근하는 것은 허용하나, 동시에 Writer를 허용하지 않는 방식 Writer보다 Reader 요청이 많은 경우 병행성을 높일 수 있다. 식사하는 철학자 문제 5명의 철학자들은 생각하고 먹는 일을 수행(철학자 : 프로세스, 젓가락 : 자원) 철학자는 양쪽의 젓가락을 사용하여 식사를 하고, 식사를 마친 철학자는 젓가락을 내려놓고 다시 생각한다. 철학자는 2개의 젓가락을 손에 쥐어야 식사를 할 수 있고, 한 번에 하나씩 잡을 수 있다. 옆 사람이 식사중이면 젓가락 잡는 것을 대기한다. 5명의 철학자가 동시에 식사를 하게 되면 모두 왼쪽 포크만을 가지게 되고 오른쪽 포크를 대기하는 교착 상태(Deadlock)이 발생한다. 이를 방지하기 위한 방법은 대표적으로 3가지이다. 최대 4명의 철학자들만이 테이블에 앉을 수 있도록 한다. =&amp;gt; 젓가락이 하나 남기 때문에 어떤 철학자는 식사가 가능하다. 한 철학자가 동시에 두개의 젓가락을 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.(즉, 임계구역 안에서만 젓가락을 집어야 한다) 비대칭 해결안을 사용한다.(홀수 번 철학자는 왼쪽, 짝수 번 철학자는 오른쪽 젓가락부터 집는다) 교착상태(DeadLock) 상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상 예방 기법 상호 배재 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다. 점유 및 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당해 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다. 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구 자원을 사용하기 위해 기다리게 한다. 환형 대기 부정 : 자원을 선형 순서로 분류해 고유 번호를 할당하고, 각 프로세스는 현재 점유한 고유 번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 한다. 회피 기법(Dijkstra 제안한 은행원 알고리즘) 안정 상태 : 모든 프로세스가 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태 불안정 상태 : 교착상태의 필수 조건으로 교착상태가 발생할 수 있는 상태 은행원 알고리즘 : 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘 각 프로세스마다 할당할 수 있는 최대 자원을 계산한다. 각 프로세스마다 자원을 할당한 후에도 안전 상태를 유지할 수 있는지 확인하고 자원을 할당한다. 추가적인 자원을 할당해도 안전 상태를 유지할 수 있다면 자원을 할당할 수 있다. 하지만 불안전상태가 된다면 교착상태가 되므로 거절한다. Available : 각 종류별로 가용한 자원의 개수, Available[i] = k 라면 R[i] 를 K개 사용할 수 있다는 뜻 Max : 각 프로세스가 최대로 필요로 하는 자원의 개수, Max[i,j] = k 라면 Process[i]가 R[j]를 K개까지 요청할 수 있다는 뜻 Allocation : 각 프로세스에게 현재 나가있는 자원의 개수, Allocation[i,j] = k 라면 현재 Process[i]가 R[j]를 K개 사용 중이라는 뜻 Need : 각 프로세스가 향후 요청할 수 있는 자원의 개수, Need[i,j] = k라면 Process[i]가 향후 R[j]를 K개 요청할 수 있다는 뜻 Need = Max - Allocation 자원 요청 알고리즘 만약 Request[i] &amp;lt;= Need[i] 이면 2단계로 이동, 아니면 시스템에 있는 개수보다 더 많이 요청했기 때문에 오류로 처리 만약 Request[i] &amp;lt;= Available[i] 이면 3단꼐로 이동, 아니면 요청한 자원이 지금 없으므로 Process[i]는 기다려야 한다. Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다. Available = Available - Request[i] Allocation[i] = Allocation[i] + Request[i] Need[i] = Need[i] - Request[i] 만약, 이렇게 바뀐 상태가 안전하다면 Process[i]에게 자원을 할당한다. 그렇지 않다면 상태를 원상태로 되돌리고 Request[i]가 만족될 때까지 기다린다. 예를 통해 알아보자. 프로세스 P와 A 자원 10개, B 자원 5개, C 자원 7개가 있을 때 다음과 같은 예시가 있다고 가정하자. Process   Allocation     Max     Need   Type A B C A B C A B C P[0] 0 1 0 7 5 3 7 4 3 P[1] 2 0 0 3 2 2 1 2 2 P[2] 3 0 2 9 0 2 6 0 0 P[3] 2 1 1 2 2 2 0 1 1 P[4] 0 0 2 4 3 3 4 3 1 Need 값은 Max - Allocation 으로 구할 수 있으며 이 경우 남은 자원 수는 다음과 같다.   Available   A B C 10 - (0+2+3+2+0) = 3 5 - (1+0+0+1+0) = 3 7 - (0+0+2+1+2) = 2 여기서 P[1]이 A 자원 1개와 C 자원 2개를 추가로 요청한다고 가정해보자. 이 때의 Request[1] = (1,0,2) 가 된다. Request[i] &amp;lt;= Need[i]를 검사한다. (1,0,2) &amp;lt;= (1,2,2)이므로 조건을 만족한다. Request[i] &amp;lt;= Available[i]를 검사한다. (1,0,2) &amp;lt;= (3,3,2) 이므로 조건을 만족한다. Process[i]에게 할당한 것처럼 시스템 상태정보를 바꿔 본다. Available[1] = Available[1] (3,3,2) - Request[1] (1,0,2) = (2,3,0) Allocation[1] = Allocation[1] (2,0,0) + Request[1] (1,0,2) = (3,0,2) Need[1] = Need[1] (1,2,2) - Request[1] (1,0,2) = (0,2,0) 위 상태는 안정 상태이므로 Process[1] 의 요청을 즉시 들어줄 수 있다. 위 예시에서는 &amp;lt;P[1], P[3], P[4], P[2], P[0]&amp;gt; 순서로 진행하면 안정 순서열이 된다.</summary></entry><entry><title type="html">OOP(객체지향 프로그래밍) 특징과 꼬리질문</title><link href="http://localhost:4000/java/2019/05/18/OOP(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8/" rel="alternate" type="text/html" title="OOP(객체지향 프로그래밍) 특징과 꼬리질문" /><published>2019-05-18T17:00:00+09:00</published><updated>2019-05-18T17:00:00+09:00</updated><id>http://localhost:4000/java/2019/05/18/OOP(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)%20%ED%8A%B9%EC%A7%95%EA%B3%BC%20%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8</id><content type="html" xml:base="http://localhost:4000/java/2019/05/18/OOP(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8/">&lt;h1 id=&quot;oop객체지향-프로그래밍&quot;&gt;OOP(객체지향 프로그래밍)&lt;/h1&gt;
&lt;p&gt;프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;코드 재사용이 용이하다.&lt;/li&gt;
  &lt;li&gt;유지보수가 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;처리속도가 상대적으로 느리다.&lt;/li&gt;
  &lt;li&gt;설계시에 많은 시간과 노력이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;클래스와-인스턴스객체&quot;&gt;클래스와 인스턴스(객체)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;클래스 : 객체의 속성(Attribute)과 행위(Behavior)를 변수와 메소드로 정의한 것&lt;/li&gt;
  &lt;li&gt;객체 : 클래스에 정의된 내용을 바탕으로 실제 메모리에 할당된 데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;oop객체지향-프로그래밍-4가지-특징캡상추다&quot;&gt;OOP(객체지향 프로그래밍) 4가지 특징(캡상추다)&lt;/h1&gt;
&lt;h2 id=&quot;1-캡슐화&quot;&gt;1. 캡슐화&lt;/h2&gt;
&lt;p&gt;객체의 멤버변수는 private로 설정하여 외부에서 접근을 거부하고, Getter/Setter를 public으로 선언하여 객체의 속성에 접근하도록 사용한다.&lt;/p&gt;

&lt;p&gt;그 이유는 객체의 무결성을 보장하기 위함인데, 객체 필드에 직접적인 접근을 거부하고 잘못된 입력에 대해 Getter/Setter는 사전에 처리 및 제한할 수 있기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;-접근자-&quot;&gt;&amp;lt; 접근자 &amp;gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;public    : 모든 클래스, 패키지에 접근이 가능한 접근 제어자&lt;/li&gt;
  &lt;li&gt;private   : 같은 패키지에서만 접근 허용, 상속받은 자식 클래스에서는 서로 다른 패키지다 하더라도 접근 가능&lt;/li&gt;
  &lt;li&gt;default   : 같은 패키지에서만 접근 허용&lt;/li&gt;
  &lt;li&gt;protected : 같은 클래스에서만 접근 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-상속&quot;&gt;2. 상속&lt;/h2&gt;
&lt;p&gt;클래스의 멤버와 함수를 다른 클래스에 물려주거나, 물려 받는 것을 말하며 이를 통해 재사용성이 높아진다.&lt;/p&gt;

&lt;h2 id=&quot;3-추상화&quot;&gt;3. 추상화&lt;/h2&gt;
&lt;p&gt;중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이를 하나의 클래스로 다루는 것&lt;/p&gt;

&lt;h2 id=&quot;4-다형성&quot;&gt;4. 다형성&lt;/h2&gt;
&lt;p&gt;오버로딩과 오버라이딩을 통해 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력&lt;/p&gt;

&lt;p&gt;오버로딩(Overloadding)    : 상위 클래스의 이름과 return값이 같지만, 매개변수를 다른 메소드를 만들어 가독성을 높이는 방법&lt;/p&gt;

&lt;p&gt;오버라이딩(Overriding)     : 상위 클래스에 존재하는 메소드를 하위 클래스에서 용도에 맞게 재정의 하여 재사용성을 높이는 방법&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;-abstract-class와-interface-&quot;&gt;&amp;lt; Abstract Class와 Interface &amp;gt;&lt;/h1&gt;
&lt;p&gt;추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스다.&lt;/p&gt;

&lt;p&gt;인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없기 때문에 상속을 통해 자식 클래스에서만 객체를 생성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;abstract-class추상-클래스&quot;&gt;Abstract Class(추상 클래스)&lt;/h2&gt;
&lt;p&gt;extends 키워드를 통해 추상 클래스를 상속받는다.&lt;/p&gt;

&lt;p&gt;추상클래스는 추상메서드(abstract method)가 하나라도 존재하는 클래스를 말한다.&lt;/p&gt;

&lt;p&gt;일부는 구현된 메소드도 있을 수 있고, 일부는 abstract method로 구현이 되어있지 않은 메소드도 있을 수 있다.&lt;/p&gt;

&lt;p&gt;즉, 구현된 메소드가 있을 수 있기 때문에 만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;interface&quot;&gt;Interface&lt;/h2&gt;
&lt;p&gt;implements 키워드를 통해 인터페이스를 상속받는다.&lt;/p&gt;

&lt;p&gt;인터페이스는 쉽게 말하면 껍데기라고 말할 수 있고, 설계도 또는 명세라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;모든 메소드가 추상 메소드이기 때문에 인터페이스를 상속받는 자식 클래스는 인터페이스의 모든 메소드를 필수적으로 구현해야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;-static-함수-&quot;&gt;&amp;lt; static 함수 &amp;gt;&lt;/h1&gt;
&lt;p&gt;메모리에 호출되는데 static 으로 함수 또는 클래스를 선언했을 경우에 컴파일 동시에 메모리에 호출된다.&lt;/p&gt;

&lt;p&gt;이렇게 호출된 static은 프로그램이 종료되는 시점까지 유지된다.&lt;/p&gt;

&lt;p&gt;Main 함수의 경우 Java에서의 프로그램의 시작과 끝이기 때문에 Static으로 선언되어야 한다.&lt;/p&gt;

&lt;p&gt;참고) Singletone 패턴&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;call-by-value-vs-call-by-reference&quot;&gt;Call by Value vs Call by Reference&lt;/h1&gt;
&lt;h2 id=&quot;call-by-value-값에-의한-호출--------java&quot;&gt;Call by Value (값에 의한 호출)        « Java&lt;/h2&gt;
&lt;p&gt;함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.&lt;/p&gt;

&lt;p&gt;함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.&lt;/p&gt;

&lt;p&gt;복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.&lt;/p&gt;

&lt;p&gt;따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;call-by-reference-참조에-의한-호출&quot;&gt;Call by Reference (참조에 의한 호출)&lt;/h2&gt;
&lt;p&gt;함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.&lt;/p&gt;

&lt;p&gt;함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가리킨다.)&lt;/p&gt;

&lt;p&gt;따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.&lt;/p&gt;

&lt;p&gt;cf) Java는 자료형은(Integer, Long, String, …) Call by Value이다. 하지만 배열, 클래스는 Call by Reference로 생각하는 것이 편하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;-stringbuffer-vs-stringbuilder-&quot;&gt;&amp;lt; StringBuffer vs StringBuilder &amp;gt;&lt;/h1&gt;
&lt;p&gt;StringBuffer    : Multi-Thread 환경에서 동기화가 가능하기 때문에 Thread-Safe하다.&lt;/p&gt;

&lt;p&gt;StringBuilder   : 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않지만 Single-Thread 환경에서 빠르다.&lt;/p&gt;

&lt;h1 id=&quot;-annotation-&quot;&gt;&amp;lt; Annotation &amp;gt;&lt;/h1&gt;
&lt;p&gt;어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다.&lt;/p&gt;

&lt;p&gt;컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공 및 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공한다.&lt;/p&gt;

&lt;p&gt;어노테이션은 컴파일러에게 이 소스코드를 어떻게 처리해야 되는 것인지 표시를 해준다.&lt;/p&gt;

&lt;p&gt;예를들어 내장 어노테이션인 @Override 경우 해당 메소드가 부모클래스를 오버라이딩 한 메소드라고 컴파일러에게 미리 일러주는 것이다.&lt;/p&gt;

&lt;p&gt;따라서 컴파일러는 런타임 이전에 이 메소드가 문제없이 오버라이딩 되었는지 검사한다.&lt;/p&gt;

&lt;h1 id=&quot;-generic-&quot;&gt;&amp;lt; Generic &amp;gt;&lt;/h1&gt;
&lt;p&gt;제네릭 타입을 이용해서 컴파일 과정에서 타입 체크를 할 수 있다.&lt;/p&gt;

&lt;p&gt;제네릭은 클래스와 인터페이스, 메소드를 정의할 때 타입 파라미터로 사용한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;컴파일할 때 타입을 체크해서 에러를 사전에 잡을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴파일러가 타입캐스팅을 해주기 때문에 개발자가 편리하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;타입만 다르고 코드의 내용이 대부분 일치할 때, 코드의 재사용성이 좋아진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;-정리-&quot;&gt;&amp;lt; 정리 &amp;gt;&lt;/h1&gt;
&lt;p&gt;모든 클래스들이 접근 가능하여야 하고, 시작되기 전 메모리에 올려져 있어야 하며, return 값에는 의미가 없기 때문에 public static void main를 사용한다.&lt;/p&gt;</content><author><name>ChanSu Kim</name></author><category term="Java 특징" /><category term="접근자" /><category term="static" /><category term="OOP" /><category term="객체지향" /><summary type="html">OOP(객체지향 프로그래밍) 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법 장점 코드 재사용이 용이하다. 유지보수가 쉽다. 단점 처리속도가 상대적으로 느리다. 설계시에 많은 시간과 노력이 필요하다. 클래스와 인스턴스(객체) 클래스 : 객체의 속성(Attribute)과 행위(Behavior)를 변수와 메소드로 정의한 것 객체 : 클래스에 정의된 내용을 바탕으로 실제 메모리에 할당된 데이터 OOP(객체지향 프로그래밍) 4가지 특징(캡상추다) 1. 캡슐화 객체의 멤버변수는 private로 설정하여 외부에서 접근을 거부하고, Getter/Setter를 public으로 선언하여 객체의 속성에 접근하도록 사용한다. 그 이유는 객체의 무결성을 보장하기 위함인데, 객체 필드에 직접적인 접근을 거부하고 잘못된 입력에 대해 Getter/Setter는 사전에 처리 및 제한할 수 있기 때문이다. &amp;lt; 접근자 &amp;gt; public : 모든 클래스, 패키지에 접근이 가능한 접근 제어자 private : 같은 패키지에서만 접근 허용, 상속받은 자식 클래스에서는 서로 다른 패키지다 하더라도 접근 가능 default : 같은 패키지에서만 접근 허용 protected : 같은 클래스에서만 접근 허용 2. 상속 클래스의 멤버와 함수를 다른 클래스에 물려주거나, 물려 받는 것을 말하며 이를 통해 재사용성이 높아진다. 3. 추상화 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이를 하나의 클래스로 다루는 것 4. 다형성 오버로딩과 오버라이딩을 통해 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력 오버로딩(Overloadding) : 상위 클래스의 이름과 return값이 같지만, 매개변수를 다른 메소드를 만들어 가독성을 높이는 방법 오버라이딩(Overriding) : 상위 클래스에 존재하는 메소드를 하위 클래스에서 용도에 맞게 재정의 하여 재사용성을 높이는 방법 &amp;lt; Abstract Class와 Interface &amp;gt; 추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스다. 인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없기 때문에 상속을 통해 자식 클래스에서만 객체를 생성할 수 있다. Abstract Class(추상 클래스) extends 키워드를 통해 추상 클래스를 상속받는다. 추상클래스는 추상메서드(abstract method)가 하나라도 존재하는 클래스를 말한다. 일부는 구현된 메소드도 있을 수 있고, 일부는 abstract method로 구현이 되어있지 않은 메소드도 있을 수 있다. 즉, 구현된 메소드가 있을 수 있기 때문에 만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용한다. Interface implements 키워드를 통해 인터페이스를 상속받는다. 인터페이스는 쉽게 말하면 껍데기라고 말할 수 있고, 설계도 또는 명세라고 생각하면 된다. 모든 메소드가 추상 메소드이기 때문에 인터페이스를 상속받는 자식 클래스는 인터페이스의 모든 메소드를 필수적으로 구현해야 한다. &amp;lt; static 함수 &amp;gt; 메모리에 호출되는데 static 으로 함수 또는 클래스를 선언했을 경우에 컴파일 동시에 메모리에 호출된다. 이렇게 호출된 static은 프로그램이 종료되는 시점까지 유지된다. Main 함수의 경우 Java에서의 프로그램의 시작과 끝이기 때문에 Static으로 선언되어야 한다. 참고) Singletone 패턴 Call by Value vs Call by Reference Call by Value (값에 의한 호출) « Java 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다. 함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다. 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다. 따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다. Call by Reference (참조에 의한 호출) 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다. 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가리킨다.) 따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다. cf) Java는 자료형은(Integer, Long, String, …) Call by Value이다. 하지만 배열, 클래스는 Call by Reference로 생각하는 것이 편하다. &amp;lt; StringBuffer vs StringBuilder &amp;gt; StringBuffer : Multi-Thread 환경에서 동기화가 가능하기 때문에 Thread-Safe하다. StringBuilder : 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않지만 Single-Thread 환경에서 빠르다. &amp;lt; Annotation &amp;gt; 어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공 및 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공한다. 어노테이션은 컴파일러에게 이 소스코드를 어떻게 처리해야 되는 것인지 표시를 해준다. 예를들어 내장 어노테이션인 @Override 경우 해당 메소드가 부모클래스를 오버라이딩 한 메소드라고 컴파일러에게 미리 일러주는 것이다. 따라서 컴파일러는 런타임 이전에 이 메소드가 문제없이 오버라이딩 되었는지 검사한다. &amp;lt; Generic &amp;gt; 제네릭 타입을 이용해서 컴파일 과정에서 타입 체크를 할 수 있다. 제네릭은 클래스와 인터페이스, 메소드를 정의할 때 타입 파라미터로 사용한다. 컴파일할 때 타입을 체크해서 에러를 사전에 잡을 수 있다. 컴파일러가 타입캐스팅을 해주기 때문에 개발자가 편리하다. 타입만 다르고 코드의 내용이 대부분 일치할 때, 코드의 재사용성이 좋아진다. &amp;lt; 정리 &amp;gt; 모든 클래스들이 접근 가능하여야 하고, 시작되기 전 메모리에 올려져 있어야 하며, return 값에는 의미가 없기 때문에 public static void main를 사용한다.</summary></entry></feed>