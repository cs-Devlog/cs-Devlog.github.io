---
title: 데이터베이스 고급 기능
date: 2019-05-29- 00:01:00
description: 3장. 트랜잭션, 병행제어, 무결성, 보안의 개념
categories:
- Database
tags: 
- Database
- 트랜잭션
- ACID
- 병행 제어
- 무결성
---
# 트랜잭션
## < 트랜잭션 정의 >
- 한꺼번에 모두 수행되어야 할 일련의 연산들
- 병행 제어 및 회복 작업시 처리되는 작업의 논리적 단위
- 하나의 트랜잭션은 Commit / RollBack된다

## < 트랜잭션 특징(ACID) >
- 원자성(Automicity)    : Do or Nothing, 트랜잭션 내의 모든 명령은 완벽히 수행되거나 전부가 취소되어야 한다.
- 일관성(Consistency)   : 트랜잭션 실행이 성공적으로 완료되면 일관성 있는 데이터베이스의 상태는 일관되어야 한다.
- 독립성(Isolation)     : 어느 하나의 트랜잭션 실행중에 다른 트랜잭션 연산이 끼어들 수 없다.
- 지속성(Durability)    : 완료된 트랜잭션은 시스템의 고장나도 영구적으로 반영되어야 한다.

- Commit 연산 : 한개의 트랜잭션에 대한 작업이 성공적으로 끝났고, 데이터베이스가 일관된 상태에 있을 때 이 트랜잭션이 수행한 연산이 완료됨을 알려주는 연산
- Rollback 연산 : 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 수행한 모든 연산을 Undo하는 연산이다.
    - Redo : 고장 발생 전, 트랜잭션이 완료 명령을 수행했다면 로그를 이용해 복원하고 Check Point 이후부터 다시 수행하는 방식
    - Undo : 고장 발생 전, 트랜잭션이 완료 명령을 수행하지 못했다면 DB에 반영된 갱신 사항을 처음까지 취소

***

# 병행제어 기법
## < 병행제어의 목적 >
- 데이터베이스 공유를 최대화한다.
- 시스템 활용도를 최대화한다.
- 데이터베이스 일관성을 유지한다.
- 사용자 응답 시간을 최소화한다.

## < 로킹(Locking) 기법 >
- 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock을 요청해서 Lock이 허락되야 그 로킹 단위를 액세스 하는 기법
- 로킹 단위 : 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미하며 로킹의 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.
    - 로킹 단위가 크면 lock 개수가 적어 관리하기 쉽지만 병행성 수준이 낮아진다.
    - 로킹 단위가 작으면 lock 개수가 많아 관리하기는 복잡하지만 병행성 수준이 높아진다.
- 데이터를 갱신할 때 잠금(Lock) → 실행(Execute) → 해제(Unlock)
- **교착상태(Deadlock)** : Lock상태가 오래 유지되어 다른 Transaction들이 더이상 진행하지 못하고 무한정 대기상태를 뜻한다

- **공유 잠금(Shared-Lock)** : 한 트랜잭션이 데이터 x에 lock-S 를 걸면 다른 트랜잭션은 데이터 x에 대해 read 가능 / write 불가능
- **배타 잠금(Exclusive-Lock)** : 한 트랜잭션이 데이터 x에 lock-X 를 걸면 다른 트랜잭션은 데이터 x에 대해 read 불가능 / write 불가능

||공유 잠금|배타 잠금|
|:----:|:---:|:---:|
|공유 잠금|접근 허용|대기|
|배타 잠금|대기|대기|

### < 2-단계 잠금 규약(Two-Phase Lock Protocol) 기법 >
- 트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법
- 확장 단계(Growing Phase)
    - Lock을 설정하는 단계, 해제 불가
    - 새로운 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계
- 축소 단계(Shirinking Phase)
    - Lock을 해제하는 단계, 잠금 불가
    - unlock 연산만 실행할 수 있고 일단 unlock 연산을 실행하면 lock 연산은 실행할 수 없는 단계
- 장점 : 직렬성 보장 / 단점 : 교착 상태 예방 불가능

### < 타임 스탬프(Time Stamp Ordering) 기법 >
- 시스템에 도착한 순서대로 타임 스탬프를 부여하여, 순서대로 실행하도록 한다.
- 교착 상태가 발생하지 않는다.

### < 로킹 규약 >
1. 트랜잭션 T가 read(x)나 write(x) 연산을 하려면 반드시 먼저 lock(x) 연산을 실행해야 한다.
2. 트랜잭션 T가 실행한 lock(x)에 대해서는 T가 모든 실행을 종료하기 전에 반드시 unlock(x)을 실행시켜야 한다.
3. 다른 트랜잭션에 의해 이미 x에 lock이 걸려있다면 다시 lock(x)를 실행할 수 없다.
4. 트랜잭션 T가 lock(x)를 실행하지 않았다면 T가 unlock(x)를 실행할 수 없다.

***

# 무결성
- **무결성** : 데이터의 정확성과 일관성을 유지하고 보증하는 것
    - 고유 무결성 : 릴레이션의 특정 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다.
    - 개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없다.
    - 참조 무결성 : 외래키 값은 NULL 이거나 참조 릴레이션의 기본키 값과 동일해야 한다.
- cf) 정확성 : 데이터베이스의 저장된 데이터 값과 현실 세계의 실제값이 일치하는 정도

***

# 보안
- 데이터베이스의 일부분 또는 전체에 대해서 권한이 없는 사용자가 엑세스하는 것을 금지하기 위한 기술
- 데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대해 다른 접근 권리/권한을 갖게 된다.

## < 암호화 기법 >
### < 개인키 암호 방식 = 대칭형 암호 알고리즘 >
- 동일한 키로 데이터 암호화/복호화 진행

1. 수신자에게 키를 전달하는 방법
    - Key를 비대칭형 암호 알고리즘을 이용하여 암호화 시킨 후 전송
2. 실제 Key를 전송하지 않고도 A와 B가 동일한 Key를 생성할 수 있도록 하는 Diffie-Hellman 알고리즘 사용

### < 공개키 암호 방식 = 비대칭형 암호 알고리즘 >
1. A는 공개키(public key)와 개인키(private key) 를 생성한다.
    - A의 공개키를 이용하여 암호화된 데이터는 A의 개인키로만 복호화가 가능하다.
    - A의 개인키를 이용하여 암호화된 데이터는 A의 공개키로만 복호화가 가능하다.
2. A와 B는 각자의 공개키를 서로에게 알려준다.
    - A : 공개A키, 개인A키, 공개B키
    - B : 공개B키, 개인B키, 공개A키
3. A는 B에게 데이터를 전송하기 위해 B의 공개B키를 이용하여 데이터를 암호화한 후 전송한다
4. 암호화된 데이터는 개인B키를 가지고 있는 B만 해독할 수 있다. 


## < 권한 부여 기법 >
- GRANT : 권한 부여 명령
    - GRANT 사용자 등급 TO 사용자 ID 리스트
- REVOKE : 권한 취소 명령
    - REVOKE 사용자 등급 FROM 사용자 ID 리스트

***

# 분산 데이터베이스
## < 분산 데이터베이스 정의 >
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 여러 개의 사이트에 분산되어 있는 데이터베이스
- 장점 : 자료의 공유성 향상, 시스템 성능 향상, 신뢰성 및 가용성이 높다
- 단점 : DBMS가 수행할 기능이 복잡, DB설계가 복잡, 소프트웨어 개발 비용이 증가